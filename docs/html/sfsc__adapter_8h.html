<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MicroSFSC: src/sfsc/sfsc_adapter/sfsc_adapter.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MicroSFSC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_60300d2efc8ea7c06e00264a83389b8a.html">sfsc</a></li><li class="navelem"><a class="el" href="dir_f6fe6e474a61eaa27ff08a7e567bf9a6.html">sfsc_adapter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sfsc_adapter.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Public header that contains all SFSC functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;../platform/sfsc_strings.h&quot;</code><br />
<code>#include &quot;../platform/sfsc_types.h&quot;</code><br />
<code>#include &quot;../proto_gen/generated.pb.h&quot;</code><br />
<code>#include &quot;sfsc_adapter_config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="sfsc__error__codes_8h_source.html">sfsc_error_codes.h</a>&quot;</code><br />
<code>#include &quot;sfsc_states.h&quot;</code><br />
</div>
<p><a href="sfsc__adapter_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__sfsc__adapter__stats.html">_sfsc_adapter_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sfsc_adapter_stats struct contains the infromation needed by the user.  <a href="struct__sfsc__adapter__stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__sfsc__buffer.html">_sfsc_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple structure to store binary data and their length.  <a href="struct__sfsc__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__sfsc__subscriber.html">_sfsc_subscriber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that contains the necessary state memory to subscribe to a publisher service.  <a href="struct__sfsc__subscriber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__sfsc__publisher.html">_sfsc_publisher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State memory for a publisher service.  <a href="struct__sfsc__publisher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__sfsc__server.html">_sfsc_server</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State memory for a server service.  <a href="struct__sfsc__server.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__sfsc__publisher__or__server.html">_sfsc_publisher_or_server</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container to point either to a sfsc_server or sfsc_publisher.  <a href="struct__sfsc__publisher__or__server.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__relative__publisher__tags.html">_relative_publisher_tags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents service tags specific to publisher services.  <a href="struct__relative__publisher__tags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__relative__server__tags.html">_relative_server_tags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents service tags specific to server services.  <a href="struct__relative__server__tags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__relative__sfsc__service__descriptor.html">_relative_sfsc_service_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents all infromation about a service.  <a href="struct__relative__sfsc__service__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__sfsc__channel__answer.html">_sfsc_channel_answer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing all information needed to answer a channel request.  <a href="struct__sfsc__channel__answer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2151f882f955ef1c4d45431331af71cd"><td class="memItemLeft" align="right" valign="top"><a id="a2151f882f955ef1c4d45431331af71cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SFSC_OK</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a2151f882f955ef1c4d45431331af71cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe828e563b401cfc0d23ddaa9f63bff"><td class="memItemLeft" align="right" valign="top"><a id="a8fe828e563b401cfc0d23ddaa9f63bff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SERVICE_TYPE_SERVER</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a8fe828e563b401cfc0d23ddaa9f63bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab826d39e60fd00275e2d32b72e6730d2"><td class="memItemLeft" align="right" valign="top"><a id="ab826d39e60fd00275e2d32b72e6730d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SERVICE_TYPE_PUBLISHER</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ab826d39e60fd00275e2d32b72e6730d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9692a0205a857ed2cc29558470c2ed77"><td class="memItemLeft" align="right" valign="top"><a id="a9692a0205a857ed2cc29558470c2ed77"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UUID_LEN</b>&#160;&#160;&#160;36</td></tr>
<tr class="separator:a9692a0205a857ed2cc29558470c2ed77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e082e8e08cd3d4193be586b88c248d3"><td class="memItemLeft" align="right" valign="top"><a id="a2e082e8e08cd3d4193be586b88c248d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sfsc_adapter_stats_DEFAULT_INIT</b>&#160;&#160;&#160;    { NULL, {UUID_LEN}, {UUID_LEN}, SFSC_STATE_NONE, 0, 0 }</td></tr>
<tr class="separator:a2e082e8e08cd3d4193be586b88c248d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d55350307413262f8d60fc251253654"><td class="memItemLeft" align="right" valign="top"><a id="a9d55350307413262f8d60fc251253654"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sfsc_buffer_DEFAULT_INIT</b>&#160;&#160;&#160;    { NULL, 0 }</td></tr>
<tr class="separator:a9d55350307413262f8d60fc251253654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b9e118813aed2661b4c7395e788c61"><td class="memItemLeft" align="right" valign="top"><a id="a09b9e118813aed2661b4c7395e788c61"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SERVICE_TOPIC_AUTOGEN</b>&#160;&#160;&#160;sfsc_buffer_DEFAULT_INIT</td></tr>
<tr class="separator:a09b9e118813aed2661b4c7395e788c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318024d8a6bab757494760e83309ac38"><td class="memItemLeft" align="right" valign="top"><a id="a318024d8a6bab757494760e83309ac38"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sfsc_subscriber_DEFAULT_INIT</b>&#160;&#160;&#160;    { sfsc_buffer_DEFAULT_INIT, NULL }</td></tr>
<tr class="separator:a318024d8a6bab757494760e83309ac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bfcf55337681b46b7bf5dda499a97e"><td class="memItemLeft" align="right" valign="top"><a id="a54bfcf55337681b46b7bf5dda499a97e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sfsc_publisher_DEFAULT_INIT</b>&#160;&#160;&#160;    { NULL, 0, 0, {0}, SERVICE_TOPIC_AUTOGEN, 0 }</td></tr>
<tr class="separator:a54bfcf55337681b46b7bf5dda499a97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743d1b07a52012e2f58d3762fd751288"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>sfsc_server_DEFAULT_INIT</b></td></tr>
<tr class="separator:a743d1b07a52012e2f58d3762fd751288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80575cdc4a52860d99c683d641dfc8c9"><td class="memItemLeft" align="right" valign="top"><a id="a80575cdc4a52860d99c683d641dfc8c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sfsc_publisher_or_server_INIT_DEFAULT</b>&#160;&#160;&#160;    { 0, NULL }</td></tr>
<tr class="separator:a80575cdc4a52860d99c683d641dfc8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572a72066ca9d9eb42efce292f76d762"><td class="memItemLeft" align="right" valign="top"><a id="a572a72066ca9d9eb42efce292f76d762"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>relative_publisher_tags_DEFAULT_INIT</b>&#160;&#160;&#160;    { 0, 0, 0, 0, 0 }</td></tr>
<tr class="separator:a572a72066ca9d9eb42efce292f76d762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebc0df905bb8a68a896b627de7ede46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>relative_server_tags_DEFAULT_INIT</b></td></tr>
<tr class="separator:a5ebc0df905bb8a68a896b627de7ede46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac641beceb65f33378234a9853e0d34d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>relative_sfsc_service_descriptor_DEFAULT_INIT</b></td></tr>
<tr class="separator:ac641beceb65f33378234a9853e0d34d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac6d9c7d2592acf83d5140e80d6c2d7b9"><td class="memItemLeft" align="right" valign="top">typedef struct _sfsc_adapter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a></td></tr>
<tr class="memdesc:ac6d9c7d2592acf83d5140e80d6c2d7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all state memory for a sfsc_adapter instance.  <a href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">More...</a><br /></td></tr>
<tr class="separator:ac6d9c7d2592acf83d5140e80d6c2d7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67512c6ef1c1f7e2e9cd669f21ec1d1b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__sfsc__adapter__stats.html">_sfsc_adapter_stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a67512c6ef1c1f7e2e9cd669f21ec1d1b">sfsc_adapter_stats</a></td></tr>
<tr class="memdesc:a67512c6ef1c1f7e2e9cd669f21ec1d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sfsc_adapter_stats struct contains the infromation needed by the user.  <a href="sfsc__adapter_8h.html#a67512c6ef1c1f7e2e9cd669f21ec1d1b">More...</a><br /></td></tr>
<tr class="separator:a67512c6ef1c1f7e2e9cd669f21ec1d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa436417a69f99cdee2a8eead1ee15adb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__sfsc__buffer.html">_sfsc_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a></td></tr>
<tr class="memdesc:aa436417a69f99cdee2a8eead1ee15adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple structure to store binary data and their length.  <a href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">More...</a><br /></td></tr>
<tr class="separator:aa436417a69f99cdee2a8eead1ee15adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c5e96d40d0a470c1bb17ec95e6c1a8"><td class="memItemLeft" align="right" valign="top"><a id="af1c5e96d40d0a470c1bb17ec95e6c1a8"></a>
typedef struct <a class="el" href="struct__sfsc__subscriber.html">_sfsc_subscriber</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sfsc_subscriber</b></td></tr>
<tr class="separator:af1c5e96d40d0a470c1bb17ec95e6c1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b6f781bf44962e1eab022433843905"><td class="memItemLeft" align="right" valign="top"><a id="a78b6f781bf44962e1eab022433843905"></a>
typedef struct <a class="el" href="struct__sfsc__publisher.html">_sfsc_publisher</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sfsc_publisher</b></td></tr>
<tr class="separator:a78b6f781bf44962e1eab022433843905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d1c1ad55e278e92e9514aaa203c621"><td class="memItemLeft" align="right" valign="top"><a id="a69d1c1ad55e278e92e9514aaa203c621"></a>
typedef struct <a class="el" href="struct__sfsc__server.html">_sfsc_server</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sfsc_server</b></td></tr>
<tr class="separator:a69d1c1ad55e278e92e9514aaa203c621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20edc615456e83ca1e18c459170457ac"><td class="memItemLeft" align="right" valign="top"><a id="a20edc615456e83ca1e18c459170457ac"></a>
typedef struct <a class="el" href="struct__sfsc__publisher__or__server.html">_sfsc_publisher_or_server</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a20edc615456e83ca1e18c459170457ac">sfsc_publisher_or_server</a></td></tr>
<tr class="memdesc:a20edc615456e83ca1e18c459170457ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container to point either to a sfsc_server or sfsc_publisher. <br /></td></tr>
<tr class="separator:a20edc615456e83ca1e18c459170457ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6ed5b87f6873abc3f42183d6c80f8e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__relative__publisher__tags.html">_relative_publisher_tags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#aed6ed5b87f6873abc3f42183d6c80f8e">relative_publisher_tags</a></td></tr>
<tr class="memdesc:aed6ed5b87f6873abc3f42183d6c80f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents service tags specific to publisher services.  <a href="sfsc__adapter_8h.html#aed6ed5b87f6873abc3f42183d6c80f8e">More...</a><br /></td></tr>
<tr class="separator:aed6ed5b87f6873abc3f42183d6c80f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6867fb92cb6c9853b21b0110a208cf60"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__relative__server__tags.html">_relative_server_tags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a6867fb92cb6c9853b21b0110a208cf60">relative_server_tags</a></td></tr>
<tr class="memdesc:a6867fb92cb6c9853b21b0110a208cf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents service tags specific to server services.  <a href="sfsc__adapter_8h.html#a6867fb92cb6c9853b21b0110a208cf60">More...</a><br /></td></tr>
<tr class="separator:a6867fb92cb6c9853b21b0110a208cf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8734edf2cb2e03719e603dec6c2d049f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__relative__sfsc__service__descriptor.html">_relative_sfsc_service_descriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a8734edf2cb2e03719e603dec6c2d049f">relative_sfsc_service_descriptor</a></td></tr>
<tr class="memdesc:a8734edf2cb2e03719e603dec6c2d049f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents all infromation about a service.  <a href="sfsc__adapter_8h.html#a8734edf2cb2e03719e603dec6c2d049f">More...</a><br /></td></tr>
<tr class="separator:a8734edf2cb2e03719e603dec6c2d049f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487711a208cf17fd8d171031dae258f8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__sfsc__channel__answer.html">_sfsc_channel_answer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a487711a208cf17fd8d171031dae258f8">sfsc_channel_answer</a></td></tr>
<tr class="memdesc:a487711a208cf17fd8d171031dae258f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing all information needed to answer a channel request.  <a href="sfsc__adapter_8h.html#a487711a208cf17fd8d171031dae258f8">More...</a><br /></td></tr>
<tr class="separator:a487711a208cf17fd8d171031dae258f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9606cb226543c2d13c6d81f6de079326"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a9606cb226543c2d13c6d81f6de079326">sfsc_command_callback</a>(<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="sfsc__adapter_8h.html#a20edc615456e83ca1e18c459170457ac">sfsc_publisher_or_server</a> service, sfsc_bool created)</td></tr>
<tr class="memdesc:a9606cb226543c2d13c6d81f6de079326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a command to create or delete a service succeeds.  <a href="sfsc__adapter_8h.html#a9606cb226543c2d13c6d81f6de079326">More...</a><br /></td></tr>
<tr class="separator:a9606cb226543c2d13c6d81f6de079326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d55712718b8b83acf89e41f66134c2"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a45d55712718b8b83acf89e41f66134c2">sfsc_query_callback</a>(<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="sfsc__adapter_8h.html#a8734edf2cb2e03719e603dec6c2d049f">relative_sfsc_service_descriptor</a> descriptor, sfsc_uint8 *offset, sfsc_size length, sfsc_bool is_last)</td></tr>
<tr class="memdesc:a45d55712718b8b83acf89e41f66134c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called during a query process with a service descriptor, or to indicate that the query process is done.  <a href="sfsc__adapter_8h.html#a45d55712718b8b83acf89e41f66134c2">More...</a><br /></td></tr>
<tr class="separator:a45d55712718b8b83acf89e41f66134c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1969b502e38168910b9e57d952369316"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a1969b502e38168910b9e57d952369316">sfsc_request_callback</a>(<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> payload, sfsc_bool timeout, void *mapping_arg, sfsc_bool *b_auto_advance)</td></tr>
<tr class="memdesc:a1969b502e38168910b9e57d952369316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when an answer to a request is receieved, or when the request times out.  <a href="sfsc__adapter_8h.html#a1969b502e38168910b9e57d952369316">More...</a><br /></td></tr>
<tr class="separator:a1969b502e38168910b9e57d952369316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1497b54b1ae44a7cac6fb4f93a8217da"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a1497b54b1ae44a7cac6fb4f93a8217da">sfsc_channel_request_callback</a>(<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, sfsc_bool timeout, sfsc_int8 decode_error, <a class="el" href="sfsc__adapter_8h.html#a8734edf2cb2e03719e603dec6c2d049f">relative_sfsc_service_descriptor</a> *descriptor, sfsc_uint8 *descirptor_offset, sfsc_size descirptor_length, void *mapping_arg, sfsc_bool *b_auto_advance)</td></tr>
<tr class="memdesc:a1497b54b1ae44a7cac6fb4f93a8217da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when an answer to a channel request is receieved, or when the request times out.  <a href="sfsc__adapter_8h.html#a1497b54b1ae44a7cac6fb4f93a8217da">More...</a><br /></td></tr>
<tr class="separator:a1497b54b1ae44a7cac6fb4f93a8217da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee1dca7def711316b62f037165b3e0"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#aaaee1dca7def711316b62f037165b3e0">sfsc_answer_ack_callback</a>(<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__server.html">sfsc_server</a> *server, sfsc_bool timeout, void *mapping_arg)</td></tr>
<tr class="memdesc:aaaee1dca7def711316b62f037165b3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked if an ack message for an answer was receieved, or the servers timeout condition was meet.  <a href="sfsc__adapter_8h.html#aaaee1dca7def711316b62f037165b3e0">More...</a><br /></td></tr>
<tr class="separator:aaaee1dca7def711316b62f037165b3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acea1c001c6a80d2a3109aedd11232f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sfsc__adapter_8h.html#a67512c6ef1c1f7e2e9cd669f21ec1d1b">sfsc_adapter_stats</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#acea1c001c6a80d2a3109aedd11232f29">adapter_stats</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter)</td></tr>
<tr class="memdesc:acea1c001c6a80d2a3109aedd11232f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recommended way to access the stats of an adapter.  <a href="sfsc__adapter_8h.html#acea1c001c6a80d2a3109aedd11232f29">More...</a><br /></td></tr>
<tr class="separator:acea1c001c6a80d2a3109aedd11232f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bd4332c56b21f6b9ce25c80eadbde4"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#ab6bd4332c56b21f6b9ce25c80eadbde4">start_session_bootstraped</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, const char *address, int original_control_pub_port)</td></tr>
<tr class="memdesc:ab6bd4332c56b21f6b9ce25c80eadbde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a sfsc adapter session with bootstraping.  <a href="sfsc__adapter_8h.html#ab6bd4332c56b21f6b9ce25c80eadbde4">More...</a><br /></td></tr>
<tr class="separator:ab6bd4332c56b21f6b9ce25c80eadbde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478abd5351cea939fd22e21ba976f97a"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a478abd5351cea939fd22e21ba976f97a">start_session</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, const char *address, int original_control_pub_port, int original_control_sub_port, int original_data_pub_port, int original_data_sub_port)</td></tr>
<tr class="memdesc:a478abd5351cea939fd22e21ba976f97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stats a sfsc adapter session without bootstraping.  <a href="sfsc__adapter_8h.html#a478abd5351cea939fd22e21ba976f97a">More...</a><br /></td></tr>
<tr class="separator:a478abd5351cea939fd22e21ba976f97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907e055e091da55aee6ea185f042bd30"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a907e055e091da55aee6ea185f042bd30">register_subscriber</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__subscriber.html">sfsc_subscriber</a> *subscriber)</td></tr>
<tr class="memdesc:a907e055e091da55aee6ea185f042bd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes to a sfsc publisher through the given adapter.  <a href="sfsc__adapter_8h.html#a907e055e091da55aee6ea185f042bd30">More...</a><br /></td></tr>
<tr class="separator:a907e055e091da55aee6ea185f042bd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaf3873c9e805b7a3b5ab72c5f59976"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#addaf3873c9e805b7a3b5ab72c5f59976">unregister_subscriber</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__subscriber.html">sfsc_subscriber</a> *subscriber)</td></tr>
<tr class="memdesc:addaf3873c9e805b7a3b5ab72c5f59976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a subscriber and unsubscribe messages on that topic.  <a href="sfsc__adapter_8h.html#addaf3873c9e805b7a3b5ab72c5f59976">More...</a><br /></td></tr>
<tr class="separator:addaf3873c9e805b7a3b5ab72c5f59976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dc86eb3be2be2995b01e366658fe7e"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a35dc86eb3be2be2995b01e366658fe7e">query_services</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="sfsc__adapter_8h.html#a45d55712718b8b83acf89e41f66134c2">sfsc_query_callback</a> *callback)</td></tr>
<tr class="memdesc:a35dc86eb3be2be2995b01e366658fe7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a query process to obtain registered services from the core.  <a href="sfsc__adapter_8h.html#a35dc86eb3be2be2995b01e366658fe7e">More...</a><br /></td></tr>
<tr class="separator:a35dc86eb3be2be2995b01e366658fe7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe50351d6b8d32fc7e8b52a63163cc6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#abe50351d6b8d32fc7e8b52a63163cc6b">query_services_next</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, sfsc_bool next)</td></tr>
<tr class="memdesc:abe50351d6b8d32fc7e8b52a63163cc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the framework to continue or to end a currently ongoing query process.  <a href="sfsc__adapter_8h.html#abe50351d6b8d32fc7e8b52a63163cc6b">More...</a><br /></td></tr>
<tr class="separator:abe50351d6b8d32fc7e8b52a63163cc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f19fd8d71709a31c43b5b6d15e5aa3"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#ae7f19fd8d71709a31c43b5b6d15e5aa3">register_publisher</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__publisher.html">sfsc_publisher</a> *publisher, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> name, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> custom_tags, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> output_message_type, <a class="el" href="sfsc__adapter_8h.html#a9606cb226543c2d13c6d81f6de079326">sfsc_command_callback</a> *callback)</td></tr>
<tr class="memdesc:ae7f19fd8d71709a31c43b5b6d15e5aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a publisher service and registers it with the core.  <a href="sfsc__adapter_8h.html#ae7f19fd8d71709a31c43b5b6d15e5aa3">More...</a><br /></td></tr>
<tr class="separator:ae7f19fd8d71709a31c43b5b6d15e5aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3a86f49777fbd148d95c724c568bdb"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a9f3a86f49777fbd148d95c724c568bdb">register_publisher_unregistered</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__publisher.html">sfsc_publisher</a> *publisher)</td></tr>
<tr class="memdesc:a9f3a86f49777fbd148d95c724c568bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a publisher you can publish with, but does not register it in the cores service registry.  <a href="sfsc__adapter_8h.html#a9f3a86f49777fbd148d95c724c568bdb">More...</a><br /></td></tr>
<tr class="separator:a9f3a86f49777fbd148d95c724c568bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19546a6860954035b355d2a8ab102493"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a19546a6860954035b355d2a8ab102493">unregister_publisher</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__publisher.html">sfsc_publisher</a> *publisher, <a class="el" href="sfsc__adapter_8h.html#a9606cb226543c2d13c6d81f6de079326">sfsc_command_callback</a> *callback)</td></tr>
<tr class="memdesc:a19546a6860954035b355d2a8ab102493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a publisher.  <a href="sfsc__adapter_8h.html#a19546a6860954035b355d2a8ab102493">More...</a><br /></td></tr>
<tr class="separator:a19546a6860954035b355d2a8ab102493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a971fb6b660a3400b6bc6fd072586e0"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a1a971fb6b660a3400b6bc6fd072586e0">publish</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__publisher.html">sfsc_publisher</a> *publisher, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> payload)</td></tr>
<tr class="memdesc:a1a971fb6b660a3400b6bc6fd072586e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes data through a publisher.  <a href="sfsc__adapter_8h.html#a1a971fb6b660a3400b6bc6fd072586e0">More...</a><br /></td></tr>
<tr class="separator:a1a971fb6b660a3400b6bc6fd072586e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccee0c80a889e4eef376a4e56e65850"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a3ccee0c80a889e4eef376a4e56e65850">request</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> topic, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> payload, sfsc_uint64 timeout_time, <a class="el" href="sfsc__adapter_8h.html#a1969b502e38168910b9e57d952369316">sfsc_request_callback</a> *callback, void *mapping_arg)</td></tr>
<tr class="memdesc:a3ccee0c80a889e4eef376a4e56e65850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a request call to a server service.  <a href="sfsc__adapter_8h.html#a3ccee0c80a889e4eef376a4e56e65850">More...</a><br /></td></tr>
<tr class="separator:a3ccee0c80a889e4eef376a4e56e65850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa683543e76eca37f8fdeb47bc9c66842"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#aa683543e76eca37f8fdeb47bc9c66842">channel_request</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> topic, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> payload, sfsc_uint64 timeout_time, <a class="el" href="sfsc__adapter_8h.html#a8734edf2cb2e03719e603dec6c2d049f">relative_sfsc_service_descriptor</a> *descriptor, sfsc_uint8 *descriptor_space, sfsc_size descriptor_space_lenght, <a class="el" href="sfsc__adapter_8h.html#a1497b54b1ae44a7cac6fb4f93a8217da">sfsc_channel_request_callback</a> *callback, void *mapping_arg)</td></tr>
<tr class="memdesc:aa683543e76eca37f8fdeb47bc9c66842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a request call to a channel server service.  <a href="sfsc__adapter_8h.html#aa683543e76eca37f8fdeb47bc9c66842">More...</a><br /></td></tr>
<tr class="separator:aa683543e76eca37f8fdeb47bc9c66842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fedfdc6248ab6e74844baeb0c2e9c0c"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a0fedfdc6248ab6e74844baeb0c2e9c0c">register_server</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__server.html">sfsc_server</a> *server, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> name, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> custom_tags, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> output_message_type, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> input_message_type, <a class="el" href="sfsc__adapter_8h.html#a9606cb226543c2d13c6d81f6de079326">sfsc_command_callback</a> *callback)</td></tr>
<tr class="memdesc:a0fedfdc6248ab6e74844baeb0c2e9c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a server service and registers it with the core.  <a href="sfsc__adapter_8h.html#a0fedfdc6248ab6e74844baeb0c2e9c0c">More...</a><br /></td></tr>
<tr class="separator:a0fedfdc6248ab6e74844baeb0c2e9c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1ce8be8feafb30fc5d182b7384c266"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a5f1ce8be8feafb30fc5d182b7384c266">unregister_server</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__server.html">sfsc_server</a> *server, <a class="el" href="sfsc__adapter_8h.html#a9606cb226543c2d13c6d81f6de079326">sfsc_command_callback</a> *callback)</td></tr>
<tr class="memdesc:a5f1ce8be8feafb30fc5d182b7384c266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a server.  <a href="sfsc__adapter_8h.html#a5f1ce8be8feafb30fc5d182b7384c266">More...</a><br /></td></tr>
<tr class="separator:a5f1ce8be8feafb30fc5d182b7384c266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03acde575324406f3d90b1196b097f5f"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a03acde575324406f3d90b1196b097f5f">answer_request</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__server.html">sfsc_server</a> *server, sfsc_int32 expected_reply_id, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> reply_topic, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> *payload, void *mapping_arg, <a class="el" href="sfsc__adapter_8h.html#aaaee1dca7def711316b62f037165b3e0">sfsc_answer_ack_callback</a> *on_ack)</td></tr>
<tr class="memdesc:a03acde575324406f3d90b1196b097f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Answers a request.  <a href="sfsc__adapter_8h.html#a03acde575324406f3d90b1196b097f5f">More...</a><br /></td></tr>
<tr class="separator:a03acde575324406f3d90b1196b097f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4b11e99ab82abe59e991775edfffaa"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a6f4b11e99ab82abe59e991775edfffaa">answer_channel_request</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__server.html">sfsc_server</a> *server, sfsc_int32 expected_reply_id, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> reply_topic, <a class="el" href="sfsc__adapter_8h.html#a487711a208cf17fd8d171031dae258f8">sfsc_channel_answer</a> *channel_answer, void *mapping_arg, <a class="el" href="sfsc__adapter_8h.html#aaaee1dca7def711316b62f037165b3e0">sfsc_answer_ack_callback</a> *callback)</td></tr>
<tr class="memdesc:a6f4b11e99ab82abe59e991775edfffaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to answer a channel request.  <a href="sfsc__adapter_8h.html#a6f4b11e99ab82abe59e991775edfffaa">More...</a><br /></td></tr>
<tr class="separator:a6f4b11e99ab82abe59e991775edfffaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7e6ee6ba9c8bf9a8bd3f6874887019"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#adb7e6ee6ba9c8bf9a8bd3f6874887019">random_uuid</a> (sfsc_uint8 target[UUID_LEN])</td></tr>
<tr class="memdesc:adb7e6ee6ba9c8bf9a8bd3f6874887019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and writes a random 128bit UUID in standard-hexgroup-format to the target buffer.  <a href="sfsc__adapter_8h.html#adb7e6ee6ba9c8bf9a8bd3f6874887019">More...</a><br /></td></tr>
<tr class="separator:adb7e6ee6ba9c8bf9a8bd3f6874887019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada689902e1addaeb4a999c775c6705d0"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#ada689902e1addaeb4a999c775c6705d0">system_task</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter)</td></tr>
<tr class="memdesc:ada689902e1addaeb4a999c775c6705d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a single system task step on the adapter.  <a href="sfsc__adapter_8h.html#ada689902e1addaeb4a999c775c6705d0">More...</a><br /></td></tr>
<tr class="separator:ada689902e1addaeb4a999c775c6705d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bb0e1bf28ae6c6b432f2e3e1e998e3"><td class="memItemLeft" align="right" valign="top">sfsc_int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#a87bb0e1bf28ae6c6b432f2e3e1e998e3">user_task</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter)</td></tr>
<tr class="memdesc:a87bb0e1bf28ae6c6b432f2e3e1e998e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a single system task step on the adapter.  <a href="sfsc__adapter_8h.html#a87bb0e1bf28ae6c6b432f2e3e1e998e3">More...</a><br /></td></tr>
<tr class="separator:a87bb0e1bf28ae6c6b432f2e3e1e998e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecc1c0af790d4a51d7b196ed1c076e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sfsc__adapter_8h.html#adecc1c0af790d4a51d7b196ed1c076e5">advance_user_ring</a> (<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter)</td></tr>
<tr class="memdesc:adecc1c0af790d4a51d7b196ed1c076e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaves the user task pause state.  <a href="sfsc__adapter_8h.html#adecc1c0af790d4a51d7b196ed1c076e5">More...</a><br /></td></tr>
<tr class="separator:adecc1c0af790d4a51d7b196ed1c076e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2f03655571bf3e74f2103b780496cf88"><td class="memItemLeft" align="right" valign="top"><a id="a2f03655571bf3e74f2103b780496cf88"></a>
const <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sfsc_buffer_default</b></td></tr>
<tr class="separator:a2f03655571bf3e74f2103b780496cf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32b1c3a552cfe42de102d6843f05f26"><td class="memItemLeft" align="right" valign="top"><a id="ab32b1c3a552cfe42de102d6843f05f26"></a>
const <a class="el" href="sfsc__adapter_8h.html#aed6ed5b87f6873abc3f42183d6c80f8e">relative_publisher_tags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>relative_publisher_tags_default</b></td></tr>
<tr class="separator:ab32b1c3a552cfe42de102d6843f05f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae541739bb6f1831887f39b700a35169a"><td class="memItemLeft" align="right" valign="top"><a id="ae541739bb6f1831887f39b700a35169a"></a>
const <a class="el" href="sfsc__adapter_8h.html#a6867fb92cb6c9853b21b0110a208cf60">relative_server_tags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>relative_server_tags_default</b></td></tr>
<tr class="separator:ae541739bb6f1831887f39b700a35169a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Public header that contains all SFSC functions. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a5ebc0df905bb8a68a896b627de7ede46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebc0df905bb8a68a896b627de7ede46">&#9670;&nbsp;</a></span>relative_server_tags_DEFAULT_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define relative_server_tags_DEFAULT_INIT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    {                                                                                  \</div>
<div class="line">        0, 0, 0, 0, 0, 0,                                                              \</div>
<div class="line">            sfsc_SfscServiceDescriptor_ServiceTags_ServerTags_AckSettings_init_default \</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac641beceb65f33378234a9853e0d34d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac641beceb65f33378234a9853e0d34d9">&#9670;&nbsp;</a></span>relative_sfsc_service_descriptor_DEFAULT_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define relative_sfsc_service_descriptor_DEFAULT_INIT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    {                                                                     \</div>
<div class="line">        sfsc_SfscId_init_default, sfsc_SfscId_init_default,               \</div>
<div class="line">            sfsc_SfscId_init_default, 0, 0, 0, 0, SERVICE_TYPE_PUBLISHER, \</div>
<div class="line">            relative_publisher_tags_DEFAULT_INIT                          \</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a743d1b07a52012e2f58d3762fd751288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743d1b07a52012e2f58d3762fd751288">&#9670;&nbsp;</a></span>sfsc_server_DEFAULT_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sfsc_server_DEFAULT_INIT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    {                                                                                   \</div>
<div class="line">        NULL,                                                                           \</div>
<div class="line">            sfsc_SfscServiceDescriptor_ServiceTags_ServerTags_AckSettings_init_default, \</div>
<div class="line">            sfsc_SfscId_init_default, SERVICE_TOPIC_AUTOGEN, 0                          \</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aed6ed5b87f6873abc3f42183d6c80f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6ed5b87f6873abc3f42183d6c80f8e">&#9670;&nbsp;</a></span>relative_publisher_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__relative__publisher__tags.html">_relative_publisher_tags</a> <a class="el" href="sfsc__adapter_8h.html#aed6ed5b87f6873abc3f42183d6c80f8e">relative_publisher_tags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents service tags specific to publisher services. </p>
<p>The format and idea of the fields is very similar to relative_sfsc_service_descriptor, see there for an explanation.</p>
<p>An exception to this is the unregistered field. See the sfsc_publisher struct documentation for an explanation. </p>

</div>
</div>
<a id="a6867fb92cb6c9853b21b0110a208cf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6867fb92cb6c9853b21b0110a208cf60">&#9670;&nbsp;</a></span>relative_server_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__relative__server__tags.html">_relative_server_tags</a> <a class="el" href="sfsc__adapter_8h.html#a6867fb92cb6c9853b21b0110a208cf60">relative_server_tags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents service tags specific to server services. </p>
<p>The format and idea of the fields is very similar to relative_sfsc_service_descriptor, see there for an explanation.</p>
<p>An exception to this is the ack_settings field. See the sfsc_server struct documentation for an explanation. </p>

</div>
</div>
<a id="a8734edf2cb2e03719e603dec6c2d049f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8734edf2cb2e03719e603dec6c2d049f">&#9670;&nbsp;</a></span>relative_sfsc_service_descriptor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__relative__sfsc__service__descriptor.html">_relative_sfsc_service_descriptor</a> <a class="el" href="sfsc__adapter_8h.html#a8734edf2cb2e03719e603dec6c2d049f">relative_sfsc_service_descriptor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents all infromation about a service. </p>
<p>A relative_sfsc_service_descriptor is relative because it does not contain information about a service directly, but it merely serves as an index structure. The indexes (which end with _offset) are relative to a memory area. The memory areas address (called start in the following) is usually delivered with the descriptor. For example, to now access the name of the service, read name_len bytes from (start+name_offset). For reasoning, why this relative apporach is used, read the last paragraph.</p>
<p>An exception to the above are the core_id, adapter_id, and service_id fields, which actually contain the respective ids, and thereby denote the core and adapter this service belongs to, as well as this services own id.</p>
<p>The service_type field is either SERVICE_TYPE_SERVER or SERVICE_TYPE_PUBLISHER and indicates, how the service_tags union should be treated.</p>
<p>Why is this relative approach used? The binary size of a serivce in sfsc is not limited, so we can not know the size of the respective service fields in advance. On the other hand, this framework does not use dynamic memory allocation (malloc). A possible solution is to statically allocate memory for each field and add an length field, to indicate, how much memory is actually used. The difference between the allocated and actually used size is called waste. Instead of allocation a memory area for each field, we use one bigger memory area for all fields. The idea is that, because of the indivudual waste, this single field size can be smaller then sum of all indivudual field sizes, while still containing enough space to store all necessary information. </p>

</div>
</div>
<a id="ac6d9c7d2592acf83d5140e80d6c2d7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d9c7d2592acf83d5140e80d6c2d7b9">&#9670;&nbsp;</a></span>sfsc_adapter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _sfsc_adapter <a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains all state memory for a sfsc_adapter instance. </p>
<p>In most cases, you do not need to interact with the fields of a sfsc_adapter struct directly. Therefor, the struct members are not exposed in this header. The for you relevant fields should be accessed throught the adapter_stats function.</p>
<p>Note however, that the compilation unit declaring the sfsc_adapter struct needs a full specification of it. Only this compilation unit should include sfsc_adapter_struct.h. </p>

</div>
</div>
<a id="a67512c6ef1c1f7e2e9cd669f21ec1d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67512c6ef1c1f7e2e9cd669f21ec1d1b">&#9670;&nbsp;</a></span>sfsc_adapter_stats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__sfsc__adapter__stats.html">_sfsc_adapter_stats</a> <a class="el" href="sfsc__adapter_8h.html#a67512c6ef1c1f7e2e9cd669f21ec1d1b">sfsc_adapter_stats</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sfsc_adapter_stats struct contains the infromation needed by the user. </p>
<p>The stats of an adapter should be accessd throught the adapter_stats function. The fields of this struct are all read-only and should not be modified by you.</p>
<p>The address field specifies the address of the core and is implicitly set by you during the start_session_bootstraped or start_session functions. The format of the address is up to you and can be anything, as long it is understood by your implementation of socket_connect (see sfsc_sockets.h).</p>
<p>The adapter_id and core_id fields indicate this adapters id and the id of the core it is connected to respectivly. They are both filled during the handshake, and ready to use once the adapters state is operational.</p>
<p>The state indicates to current connection state of an adapter. The various states are defined in sfsc_states.h and are all prefixed with SFSC_STATE_. An adapter is considered operational if the value of this field is &gt;= SFSC_STATE_OPERATIONAL.</p>
<p>Due to the execution and memory model of this framework it can occur that some messages receieved from the network are dropped (see the system_task function for details). The discarded_message_count keeps track of the number of lost messages.</p>
<p>The query_in_progress is set to 1 if you started a query process using query_services, and will be reset to 0 if the query process is terminated. See the query functions for more information. </p>

</div>
</div>
<a id="aaaee1dca7def711316b62f037165b3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaee1dca7def711316b62f037165b3e0">&#9670;&nbsp;</a></span>sfsc_answer_ack_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() sfsc_answer_ack_callback(<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__server.html">sfsc_server</a> *server, sfsc_bool timeout, void *mapping_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoked if an ack message for an answer was receieved, or the servers timeout condition was meet. </p>
<p>If timeout is set to 1 all retransmission attempts failed (see the sfsc_server.ack_settings), if it is set to 0, the requestor acknowledged the answer.</p>
<p>The mapping_arg parameter is a mapping-argument (explained in the request functions documentation with an example). </p>

</div>
</div>
<a id="aa436417a69f99cdee2a8eead1ee15adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa436417a69f99cdee2a8eead1ee15adb">&#9670;&nbsp;</a></span>sfsc_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__sfsc__buffer.html">_sfsc_buffer</a> <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple structure to store binary data and their length. </p>
<p>This structure type is widely used in the framework for compact data storing. It is important to notice that some functions will take a sfsc_buffer struct as parameter directly, while others will work with pointers. In the most cases, this says something about the mutality of the content.</p>
<p>In general, for the use-time of a sfsc_buffer (usually defined in the respective functions documentation), the memory area the buffer points to must be valid and of the in the struct specified length.</p>
<p>When passing the struct to a function, it must be immutable, meaning that for the use-time of the sfsc_buffer, the content must not change.</p>
<p>When passing a pointer to a function, the content is allowed to be mutable, meaning that during the use-time of the sfsc_buffer, you are allowed to change the content pointer and thereby change the memory area are this sfsc_buffer is backed by. If you do so, don't forget to update the length field accordingly. </p>

</div>
</div>
<a id="a487711a208cf17fd8d171031dae258f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487711a208cf17fd8d171031dae258f8">&#9670;&nbsp;</a></span>sfsc_channel_answer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__sfsc__channel__answer.html">_sfsc_channel_answer</a> <a class="el" href="sfsc__adapter_8h.html#a487711a208cf17fd8d171031dae258f8">sfsc_channel_answer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A struct containing all information needed to answer a channel request. </p>
<p>Instead of normal binary payload, a channel request is answered with the definition of a publisher service.</p>
<p>The core_id, adapter_id and service_id represent the core and adapter the publisher service is conencted to, as well as the publisher service itself. Their length must be UUID_LEN and their format must be standard-hexgroup-format (see the random_uuid function). The reason a sfsc_channel_answer uses sfsc_uint8* instead of sfsc_uint8[] is to remove copying and to save memory: The publisher you are describing is most likly hosted by the same adapter that will send this channel answer. Instead of allocating 3*UUID_LEN memory and copy the details from the adapter to the sfsc_channel_answer, you can just let the fields point to &amp;adapter_states()-&gt;core_id and &amp;adapter_states()-&gt;adapter_id respectivly.</p>
<p>All sfsc_buffers must be valid during the use-time of the sfsc_channel_answer struct and are optional. If publisher_output_topic is set to SERVICE_TOPIC_AUTOGEN the topic autogenerate rule (as described in sfsc_publisher) will be applied, and the service_id will be used as topic.</p>
<p>The unregistered should be set to 0 if the publisher you are describing in this sfsc_channel_answer is also registered in the service registry, or to 1 if it is not. </p>

</div>
</div>
<a id="a1497b54b1ae44a7cac6fb4f93a8217da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1497b54b1ae44a7cac6fb4f93a8217da">&#9670;&nbsp;</a></span>sfsc_channel_request_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() sfsc_channel_request_callback(<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, sfsc_bool timeout, sfsc_int8 decode_error, <a class="el" href="sfsc__adapter_8h.html#a8734edf2cb2e03719e603dec6c2d049f">relative_sfsc_service_descriptor</a> *descriptor, sfsc_uint8 *descirptor_offset, sfsc_size descirptor_length, void *mapping_arg, sfsc_bool *b_auto_advance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoked when an answer to a channel request is receieved, or when the request times out. </p>
<p>The timeout parameter is set to 1 if the callback invokation is caused by a timeout, to 0 if an answer is deleivered.</p>
<p>The mapping_arg parameter is a mapping-argument (explained in the request functions documentation with an example).</p>
<p>If decode_error is not SFSC_OK, an error occured during decoding the received service definition. This will most likley happen due to a too small memory area for the descriptor. In this case decode_error is set to E_BUFFER_INSUFFICIENT, and descirptor_length indicates, how much memory would have been needed.</p>
<p>In contrast to the payload in a normal sfsc_request_callback, you have allocated the descriptor struct and the descriptor memory area yourself, so they will be valid until you do something with them, and won't become invalid once the callback returns. Thus, the b_auto_advance does not influence the validity, and is just there as a convenience tool to enter the user task pause state (see the user_task documentation). </p>

</div>
</div>
<a id="a9606cb226543c2d13c6d81f6de079326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9606cb226543c2d13c6d81f6de079326">&#9670;&nbsp;</a></span>sfsc_command_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() sfsc_command_callback(<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="sfsc__adapter_8h.html#a20edc615456e83ca1e18c459170457ac">sfsc_publisher_or_server</a> service, sfsc_bool created)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a command to create or delete a service succeeds. </p>
<p>A create command means that the service was registered in the cores event-log, a delete command means taht the service was unregistred from it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>the executing adapter </td></tr>
    <tr><td class="paramname">service</td><td>a struct describing the service </td></tr>
    <tr><td class="paramname">created</td><td>1 if the command was a create command, 0 if it was a delete command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45d55712718b8b83acf89e41f66134c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d55712718b8b83acf89e41f66134c2">&#9670;&nbsp;</a></span>sfsc_query_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() sfsc_query_callback(<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="sfsc__adapter_8h.html#a8734edf2cb2e03719e603dec6c2d049f">relative_sfsc_service_descriptor</a> descriptor, sfsc_uint8 *offset, sfsc_size length, sfsc_bool is_last)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called during a query process with a service descriptor, or to indicate that the query process is done. </p>
<p>The descriptor is valid as long as you don't continue the query process (using query_services_next). If you need to access the service data of a service delivered by the callback after continuation, you need to write the descriptor to a global place, and also copy length bytes from offset to a global place. Alternatively, if you call query_services_next to end the query process (by setting next to 0), the descriptor is valid until the next query process.</p>
<p>In the last call to this method, is_last is set to 1. The last call might not contain a service. An offset value of NULL indicates that this invokation of the callback does not contain a service.</p>
<p>Even after the is_last call you have to invoke query_services_next with next set to 0, to explicitly end the query process. </p>

</div>
</div>
<a id="a1969b502e38168910b9e57d952369316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1969b502e38168910b9e57d952369316">&#9670;&nbsp;</a></span>sfsc_request_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() sfsc_request_callback(<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> payload, sfsc_bool timeout, void *mapping_arg, sfsc_bool *b_auto_advance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoked when an answer to a request is receieved, or when the request times out. </p>
<p>The timeout parameter is set to 1 if the callback invokation is caused by a timeout, to 0 if an answer is deleivered.</p>
<p>mapping_arg is a mapping-argument (explained in the request functions documentation with an example).</p>
<p>The payload buffer is only valid during the current user task micro step (see the user_task documentation). b_auto_advance is an out-parameter (meaning that you should set it), that lets you pause the user task on the current mirco step: if you set it to 0, you will enter the pause state and the payload pointer will be valid, even after the callback returns. On the other hand, the user task will not advance to the next micro step until you leave the pause state manually (see advance_user_ring). Usually, you want to set b_auto_advance to 1. If the request timed out, you should not modify b_auto_advance, as it will point to NULL. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acea1c001c6a80d2a3109aedd11232f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea1c001c6a80d2a3109aedd11232f29">&#9670;&nbsp;</a></span>adapter_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sfsc__adapter_8h.html#a67512c6ef1c1f7e2e9cd669f21ec1d1b">sfsc_adapter_stats</a>* adapter_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recommended way to access the stats of an adapter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>The target adapter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_adapter_stats* Pointer to that adapers stats </dd></dl>

</div>
</div>
<a id="adecc1c0af790d4a51d7b196ed1c076e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecc1c0af790d4a51d7b196ed1c076e5">&#9670;&nbsp;</a></span>advance_user_ring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void advance_user_ring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leaves the user task pause state. </p>
<p>Some callback functions allow you to pause the user task and freeze it on the current micro step. To continue execution you have to call this function. You should only call this funtion if you entered the pause state, and never call it from the callback you entered the pause state, as this will skip messages and leave your adapter in a undefined state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>The adapter whichs user task is currently in the pause state and should continue execution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f4b11e99ab82abe59e991775edfffaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4b11e99ab82abe59e991775edfffaa">&#9670;&nbsp;</a></span>answer_channel_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 answer_channel_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__sfsc__server.html">sfsc_server</a> *&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sfsc_int32&#160;</td>
          <td class="paramname"><em>expected_reply_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>reply_topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#a487711a208cf17fd8d171031dae258f8">sfsc_channel_answer</a> *&#160;</td>
          <td class="paramname"><em>channel_answer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mapping_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aaaee1dca7def711316b62f037165b3e0">sfsc_answer_ack_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to answer a channel request. </p>
<p>This function must only be called by channel server services. It behaves just like answer_request, so see there for documentation.</p>
<p>The only difference is that instead of passing a pointer to a binary payload, you have to pass a pointer to a sfsc_channel_answer. The channel_answers use-time equals the use-time of the payload in the answer_request function. It is also mutable, meaning that you are allowed to edit it. </p>

</div>
</div>
<a id="a03acde575324406f3d90b1196b097f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03acde575324406f3d90b1196b097f5f">&#9670;&nbsp;</a></span>answer_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 answer_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__sfsc__server.html">sfsc_server</a> *&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sfsc_int32&#160;</td>
          <td class="paramname"><em>expected_reply_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>reply_topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mapping_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aaaee1dca7def711316b62f037165b3e0">sfsc_answer_ack_callback</a> *&#160;</td>
          <td class="paramname"><em>on_ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Answers a request. </p>
<p>After sending an answer, the original requestor will (hopefully) receive it and send an acknowledge for the answer. If the acknowledge is received in time, the on_ack callback will be invoked. If not, an attempt is automatically made to send it again. The maximal send again attempt count and the wait time are configured in the server_struct (see there for more information). If a server does not require its answers to be acknowledged and which are thus only send once, it is called a fire-and-forget server.</p>
<p>The expected_reply_id and reply_topic are given to you by the on_request function of the corresponding sfsc_server. The use-time of the reply_topic is the time until the on_ack callback is invoked. During this time, it must be valid and immutable. For fire-and-forget servers, the use-time of the reply_topic is only this functions runtime, meaning that its only neccessary to be vaid and immutable until this function returns.</p>
<p>The payload parameter is a pointer to the actual payload you want to transmitt in the answer. The use-time for this is either until the on_ack callback is invoked, or for fire-and-forget servers, this functions runtime. Since this is a pointer to a sfsc_buffer and not a sfsc_buffer, both, the pointer to the sfsc_buffer and the content pointer inside that buffer must be valid during the use-time. The payload buffer can be mutable: you are allowed to change the content pointer or the content it points to. This is usefull in some situation, e.g.: Imaging answering a request with a sensor measurement, stored behind payload-&gt;content. You do not receieve an acknowledge in time, so the answer is send again. But during this peroid, the the measurement changed. Since you were allowed to change payload-&gt;content, you updated it, and the retransmission of the answer will contain the new measurement.</p>
<p>Answering a request to an non-fire-and-forget server will require a free acknowledge memory slot. If an attempt is made to answer a request on such a server and there are already MAX_PENDING_ACKS answer processes ongoing, a E_NO_FREE_SLOT will be returned. The acknowledge memory slot is freed once the on_ack callback is invoked.</p>
<p>The mapping_arg parameter is a mapping-argument (explained in the request functions documentation with an example).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>An operational adapter </td></tr>
    <tr><td class="paramname">server</td><td>The server that is answering a request </td></tr>
    <tr><td class="paramname">expected_reply_id</td><td>An answer identification number obtained by the original request </td></tr>
    <tr><td class="paramname">reply_topic</td><td>The answers reply topic, obtained by the original request </td></tr>
    <tr><td class="paramname">payload</td><td>The actual answer payload </td></tr>
    <tr><td class="paramname">mapping_arg</td><td>Optional; Serves as mapping-argument </td></tr>
    <tr><td class="paramname">on_ack</td><td>A callback to invoke once an acknowledge is received, can be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK or one of the error codes below </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">E_NO_FREE_SLOT</td><td>If there is no free acknowledge memory slot while trying to answer a non-fire-and-forget request </td></tr>
    <tr><td class="paramname">Various</td><td>Network Errors There are serveral other, network-related errors that can occure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa683543e76eca37f8fdeb47bc9c66842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa683543e76eca37f8fdeb47bc9c66842">&#9670;&nbsp;</a></span>channel_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 channel_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sfsc_uint64&#160;</td>
          <td class="paramname"><em>timeout_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#a8734edf2cb2e03719e603dec6c2d049f">relative_sfsc_service_descriptor</a> *&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sfsc_uint8 *&#160;</td>
          <td class="paramname"><em>descriptor_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sfsc_size&#160;</td>
          <td class="paramname"><em>descriptor_space_lenght</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#a1497b54b1ae44a7cac6fb4f93a8217da">sfsc_channel_request_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mapping_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a request call to a channel server service. </p>
<p>This function behaves like the request function, so see there for documentation. The only difference is, what the answer is, and how it is delivered.</p>
<p>Instead of normal binary payload, a channel_request will result in a publisher service description as answer, in the same format as the query_service function would return it. The difference to the query_service function is, that the framework can not know, how many simultaneous channel requests you want to make. Thus it can not statically allocate memory for the service descriptors. As consequence, you have to allocate this memory yourself and pass it to this method. The memory must be large enough to hold the received service. If you do not know anything about the size of the service, it might be a good idea to use REGISTRY_BUFFER_SIZE as orientation. What happens if the descriptor_space_length is insufficient is described in the sfsc_channel_request_callback documentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptor</td><td>Pointer to a relative_sfsc_service_descriptor which will be filled </td></tr>
    <tr><td class="paramname">descriptor_space</td><td>Pointer to the start of the usable memory area </td></tr>
    <tr><td class="paramname">descriptor_space_lenght</td><td>Length of the usable memory area </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a971fb6b660a3400b6bc6fd072586e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a971fb6b660a3400b6bc6fd072586e0">&#9670;&nbsp;</a></span>publish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__sfsc__publisher.html">sfsc_publisher</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publishes data through a publisher. </p>
<p>The publisher must be registered with this adapter, either by the register_publisher or the register_publisher_unregistered function.</p>
<p>The use-time of the payload is this functions runtime and must be immutable for the duration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>An operational adapter this publisher is registered to </td></tr>
    <tr><td class="paramname">publisher</td><td>The publisher to publish the data </td></tr>
    <tr><td class="paramname">payload</td><td>The data to publish </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK </dd></dl>

</div>
</div>
<a id="a35dc86eb3be2be2995b01e366658fe7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dc86eb3be2be2995b01e366658fe7e">&#9670;&nbsp;</a></span>query_services()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 query_services </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#a45d55712718b8b83acf89e41f66134c2">sfsc_query_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a query process to obtain registered services from the core. </p>
<p>Only one query process might be running simultaniously. During a query process, all valid services will be delivered through the callback. The query process queries the cores event log in reversed order, so that more recently registered services will be found first.</p>
<p>After a service is found and delivered to the calling application throught the callback, the query process is paused, until it is explicitly continued by a call to the query_services_next function. See the documentation of the sfsc_query_callback for more information on the delivered service data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>An operational adapter throught which the core is queried </td></tr>
    <tr><td class="paramname">callback</td><td>The callback all receieved services are delivered to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK if starting the query process was successfull, or one of the error codes below </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">E_QUERY_IN_PROGRESS</td><td>If there is already an other query process </td></tr>
    <tr><td class="paramname">Various</td><td>Network Errors There are serveral other, network-related errors that can occure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe50351d6b8d32fc7e8b52a63163cc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe50351d6b8d32fc7e8b52a63163cc6b">&#9670;&nbsp;</a></span>query_services_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void query_services_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sfsc_bool&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the framework to continue or to end a currently ongoing query process. </p>
<p>Once a service is found during the query process, the associated callback is invoked and the query process enters a pause state. It is then either continued by a call to this function with next set to 1 or ended with next set to 0.</p>
<p>It is not neccesary, but allowed, that this function is invoked from a query callback. It is also allowed for it to be invoked from any other part of the programm, as long as it is invoked eventually.</p>
<p>Calling this function while there is no query process ongoing (checkable by the adapter_stats function) will result in undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>The adapter which is currently in a query process </td></tr>
    <tr><td class="paramname">next</td><td>1 to continue the query process, 0 to end it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb7e6ee6ba9c8bf9a8bd3f6874887019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7e6ee6ba9c8bf9a8bd3f6874887019">&#9670;&nbsp;</a></span>random_uuid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void random_uuid </td>
          <td>(</td>
          <td class="paramtype">sfsc_uint8&#160;</td>
          <td class="paramname"><em>target</em>[UUID_LEN]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and writes a random 128bit UUID in standard-hexgroup-format to the target buffer. </p>
<p>Since the generated UUID is random, it can be classified as type 4 UUID.</p>
<p>This method generates 2 random sfsc_uint64 and formats them in standard-hexgroup-format. Standard-hexgroup-format consists of 5 datagroups, each group represended by ASCII letters a-f and numbers 0-9. The groups are separated by the - ASCII symbol.</p>
<p>Examples: 23236572-6963-6973-7473-757065722323, 550e8400-e29b-11d4-a716-446655440000</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>A at least UUID_LEN bytes long buffer to write the formated UUID to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7f19fd8d71709a31c43b5b6d15e5aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f19fd8d71709a31c43b5b6d15e5aa3">&#9670;&nbsp;</a></span>register_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 register_publisher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__sfsc__publisher.html">sfsc_publisher</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>custom_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>output_message_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#a9606cb226543c2d13c6d81f6de079326">sfsc_command_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a publisher service and registers it with the core. </p>
<p>If you want to set up the services id and topic manually, see the sfsc_publisher struct documentation for instructions.</p>
<p>After successfull registration, this function will set the unregistered field of the publisher to 0.</p>
<p>All sfsc_buffer parameters for this method must be immutable and mut be valid until this function returns (their use-time equals this functions run time). For more information about mutability, see the sfsc_buffer struct documentation. To omit an optional sfsc_buffer parameter use sfsc_buffer_default as value.</p>
<p>Registering a publisher saves a pointer to that publisher in the adapter state, so you must not copy the publisher struct around as long as it is registered with the adapter! Also, registering will fail if there is no free publisher memory slot to store the pointer to that publisher in the adapter. In this case E_NO_FREE_SLOT will be returned. The maximal number of at the same time registered publisher per adapter can be configured using MAX_PUBLISHERS.</p>
<p>Also, since the publisher will be registered in the service registry, this call requires a free command memory slot and will also return E_NO_FREE_SLOT if their are currently already MAX_SIMULTANIOUS_COMMANDS ongoing. The command memory slot will be occupied until the callback is invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>An operational adapter </td></tr>
    <tr><td class="paramname">publisher</td><td>The publisher to register with this adapter, see the sfsc_publisher struct for more information </td></tr>
    <tr><td class="paramname">name</td><td>The name of this publisher </td></tr>
    <tr><td class="paramname">custom_tags</td><td>Optional; custom tags for the publisher </td></tr>
    <tr><td class="paramname">output_message_type</td><td>Optional; can be used to annotate the format of the published messages </td></tr>
    <tr><td class="paramname">callback</td><td>Optional; a callback that is invoked after service registration with the core was successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK or one of the error codes below </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SFSC_OK</td><td>This indicates that registering the publisher into the adapter was successfull, and that the appropriate command to register the publisher into the cores service registry was issued. </td></tr>
    <tr><td class="paramname">E_NO_FREE_SLOT</td><td>There are already MAX_PUBLISHERS registered with this adapter, so there is no memory slot left for this one OR if there are currently already MAX_SIMULTANIOUS_COMMANDS ongoing </td></tr>
    <tr><td class="paramname">Various</td><td>Network Errors There are serveral other, network-related errors that can occure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f3a86f49777fbd148d95c724c568bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3a86f49777fbd148d95c724c568bdb">&#9670;&nbsp;</a></span>register_publisher_unregistered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 register_publisher_unregistered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__sfsc__publisher.html">sfsc_publisher</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a publisher you can publish with, but does not register it in the cores service registry. </p>
<p>This function behaves mostly like register_publisher, but since this publisher is not registered into the service registry, it does not have a name, custom_tags or an ouput_message_type.</p>
<p>It will still have an service id and a topic, which are either setup manually or automaticly generated, according to the rules specified in the sfsc_publisher documentation. Also, for registering the publisher with the adapter, the adapter needs to have a free publisher memory slot (again, see register_publisher).</p>
<p>This function will set the unregistred field of the publisher to 1.</p>
<p>A subscriber can subscribe to an unregistred publisher, if it knows the unregistered publishers topic. In most cases, this will happen in the context of a channel request.</p>
<p>Even if the publisher is not registered into the service registry, it sill needs to be properly unregistered form the adapter after usage by the unregister_publisher function!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>An operational adapter </td></tr>
    <tr><td class="paramname">publisher</td><td>The publisher to register with this adapter, see the sfsc_publisher struct for more information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK or one of the error codes below </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SFSC_OK</td><td>This indicates that registering the publisher into the adapter was successfull, and that the appropriate command to register the publisher into the cores service registry was issued. </td></tr>
    <tr><td class="paramname">E_NO_FREE_SLOT</td><td>There are already MAX_PUBLISHERS registered with this adapter, so there is no memory slot left for this one </td></tr>
    <tr><td class="paramname">Various</td><td>Network Errors There are serveral other, network-related errors that can occure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fedfdc6248ab6e74844baeb0c2e9c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fedfdc6248ab6e74844baeb0c2e9c0c">&#9670;&nbsp;</a></span>register_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 register_server </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__sfsc__server.html">sfsc_server</a> *&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>custom_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>output_message_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>input_message_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#a9606cb226543c2d13c6d81f6de079326">sfsc_command_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a server service and registers it with the core. </p>
<p>If you want to set up the services id and topic manually, see the sfsc_server struct documentation for instructions.</p>
<p>Also, the function that is invoked when recieving requests, the servers acknowledge strategy and if this is a channel service must be configured in the sfsc_server before calling this function, so see their for instructions.</p>
<p>All sfsc_buffer parameters for this method must be immutable and must be valid until this function returns (their use-time equals this functions run time). For more information about mutability, see the sfsc_buffer struct documentation. To omit an optional sfsc_buffer parameter use sfsc_buffer_default as value.</p>
<p>Registering a server saves a pointer to that server in the adapter state, so you must not copy the server struct around as long as it is registered with the adapter! Also, registering will fail if there is no free server memory slot to store the pointer to that server in the adapter. In this case E_NO_FREE_SLOT will be returned. The maximal number of at the same time registered server per adapter can be configured using MAX_SERVERS.</p>
<p>Also, since the server will be registered in the service registry, this call requires a free command memory slot and will also return E_NO_FREE_SLOT if their are currently already MAX_SIMULTANIOUS_COMMANDS ongoing. The command memory slot will be occupied until the callback is invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>An operational adapter </td></tr>
    <tr><td class="paramname">server</td><td>The server to register with this adapter, see the sfsc_server struct for more information </td></tr>
    <tr><td class="paramname">name</td><td>The name of this server </td></tr>
    <tr><td class="paramname">custom_tags</td><td>Optional; custom tags for the server </td></tr>
    <tr><td class="paramname">output_message_type</td><td>Optional; can be used to annotate the format of the messages the server sends as answers </td></tr>
    <tr><td class="paramname">input_message_type</td><td>Optional; can be used to annotate the format of the messages the server accepts on requests </td></tr>
    <tr><td class="paramname">callback</td><td>Optional; a callback that is invoked after service registration with the core was successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK or one of the error codes below </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SFSC_OK</td><td>This indicates that registering the server into the adapter was successfull, and that the appropriate command to register the into into the cores service registry was issued. </td></tr>
    <tr><td class="paramname">E_NO_FREE_SLOT</td><td>There are already MAX_SERVERS registered with this adapter, so there is no memory slot left for this one OR if there are currently already MAX_SIMULTANIOUS_COMMANDS ongoing </td></tr>
    <tr><td class="paramname">Various</td><td>Network Errors There are serveral other, network-related errors that can occure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a907e055e091da55aee6ea185f042bd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907e055e091da55aee6ea185f042bd30">&#9670;&nbsp;</a></span>register_subscriber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 register_subscriber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__sfsc__subscriber.html">sfsc_subscriber</a> *&#160;</td>
          <td class="paramname"><em>subscriber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribes to a sfsc publisher through the given adapter. </p>
<p>The publishers topic which should be subscribed to and the callback function which should be invoked can be set in the corresponding sfsc_subscriber struct. For mutability rules of topic and callback function (if they are allowed to change), see the sfsc_subscriber structs documentation.</p>
<p>Registering a subscriber saves a pointer to that subscriber in the adapter state, so you must not copy the subscriber struct around as long as it is registered with the adapter! Also, registering will fail if there is no free subscriber memory slot to store the pointer to that subscriber in the adapter. In this case E_NO_FREE_SLOT will be returned. The maximal number of at the same time registered subscribers per adapter can be configured using MAX_SUBSCRIBERS.</p>
<p>Calling this function with an non-operational adapter will result in unpredictable behaviour! Registering the same subscriber multiple times will also result in unpredictable behaviour!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>An operational adapter which will be used for the subscription </td></tr>
    <tr><td class="paramname">subscriber</td><td>Pointer to the subscriber struct holding the topic and callback information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK on success or one of the error codes below </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">E_NO_FREE_SLOT</td><td>There are already MAX_SUBSCRIBERS registered with this adapter, so there is no memory slot left for this one </td></tr>
    <tr><td class="paramname">Various</td><td>Network Errors There are serveral other, network-related errors that can occure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ccee0c80a889e4eef376a4e56e65850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ccee0c80a889e4eef376a4e56e65850">&#9670;&nbsp;</a></span>request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sfsc_uint64&#160;</td>
          <td class="paramname"><em>timeout_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#a1969b502e38168910b9e57d952369316">sfsc_request_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mapping_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a request call to a server service. </p>
<p>The topic of the server service is usually obtained by a registry query. The use-time of the topic and the payload equal the functions runtime ( until this function returns) and must both be immutable for this time (see the sfsc_buffer documentation for more information about mutability).</p>
<p>If an answer to the request is received, the callback is invoked. For information on how the data will be delivered, see the callbacks documentation.</p>
<p>You can specify a timeout_time in ms. If this time passes without receiving an answer to this request, the callback is invoked with timeout set to 1.</p>
<p>Each request you want to make needs a request memory slot in the given adapter for the time of the request (until the callback is invoked). If there is no free request memory slot, E_NO_FREE_SLOT will be returned. You can configure the amount of available request memory slots using MAX_SIMULTANIOUS_REQUESTS.</p>
<p>As the use-time of the request topic and payload is only the functions runtime, they are both not necessarily valid when an answer is recieved, and thus can not be passed to the callback. But most certainly you want to know to which request the recieved answer belongs. One way is to declare a separate callback function for each of your requests. An other way to let you know which request function call the callbacks invokation belongs to, is to use the optional mapping_arg parameter as a so called mapping-argument. If and what you store behind the mapping_arg pointer is opaque to the framework. The callback function will be invoked with this mapping_arg. You can then, based on the mapping_arg, reason, what request call the answer belongs to. For example, if you know that even if the use-time of the request topic buffer is over it will continue to be valid, you can pass this as mapping_arg. Or you define that you will use the mapping_arg pointer as numerical value and treat it as an normal integer number instead of a pointer. Then you can assign unique request ids to your topics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>The operational adapter to make the request with </td></tr>
    <tr><td class="paramname">topic</td><td>The server services topic to make the request to </td></tr>
    <tr><td class="paramname">payload</td><td>The payload of the request </td></tr>
    <tr><td class="paramname">timeout_time</td><td>The timeout time in ms, 0 for no timeout restrictions </td></tr>
    <tr><td class="paramname">callback</td><td>The callback that is invoked when receiving an answer or on timeout </td></tr>
    <tr><td class="paramname">mapping_arg</td><td>Optional; Serves as mapping-argument (see the text above for explanation) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK or one of the error codes below </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SFSC_OK</td><td>This indicates that registering the publisher into the adapter was successfull, and that the appropriate command to register the publisher into the cores service registry was issued. </td></tr>
    <tr><td class="paramname">E_NO_FREE_SLOT</td><td>There currently already MAX_SIMULTANIOUS_REQUESTS MAX_PUBLISHERS ongoing </td></tr>
    <tr><td class="paramname">Various</td><td>Network Errors There are serveral other, network-related errors that can occure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a478abd5351cea939fd22e21ba976f97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478abd5351cea939fd22e21ba976f97a">&#9670;&nbsp;</a></span>start_session()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 start_session </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>original_control_pub_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>original_control_sub_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>original_data_pub_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>original_data_sub_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stats a sfsc adapter session without bootstraping. </p>
<p>See start_session_bootstraped for details. </p>

</div>
</div>
<a id="ab6bd4332c56b21f6b9ce25c80eadbde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bd4332c56b21f6b9ce25c80eadbde4">&#9670;&nbsp;</a></span>start_session_bootstraped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 start_session_bootstraped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>original_control_pub_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a sfsc adapter session with bootstraping. </p>
<p>The adapter is not operational after this function returns. It first needs to do a handshake and connect to the other sfsc sockets of the core. You should start system-tasking (see the system_task function) with this adapter and check the state field of the stats object (accessible with the adapter_stats function) after each step. It will eventually become SFSC_STATE_OPERATIONAL, making the adapter operational.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>Pointer to the adapter struct, all state information will be saved there </td></tr>
    <tr><td class="paramname">address</td><td>The address of the core, it will be passed to your socket implementation </td></tr>
    <tr><td class="paramname">original_control_pub_port</td><td>The port of the cores control pub socket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK or an error code </dd></dl>

</div>
</div>
<a id="ada689902e1addaeb4a999c775c6705d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada689902e1addaeb4a999c775c6705d0">&#9670;&nbsp;</a></span>system_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 system_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a single system task step on the adapter. </p>
<p>This function is non-blocking, and must be called cyclicly, with a high enough frequency on an adapter, on which the start_session or start_session_bootstraped function was called. To read more about the execution model, see the readme.</p>
<p>This function returns an error code, which is SFSC_OK on success. An other return code indicates an error, a list or error codes can be found in sfsc_errors.h and zmtp_states.h. Some errors are recoverable, again, see the readme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>An adapter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK or an error code </dd></dl>

</div>
</div>
<a id="a19546a6860954035b355d2a8ab102493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19546a6860954035b355d2a8ab102493">&#9670;&nbsp;</a></span>unregister_publisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 unregister_publisher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__sfsc__publisher.html">sfsc_publisher</a> *&#160;</td>
          <td class="paramname"><em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#a9606cb226543c2d13c6d81f6de079326">sfsc_command_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a publisher. </p>
<p>Unregistering frees the publishers publisher memory slot in the adapter.</p>
<p>If this publisher is registered with the service registry, it will be removed from it. Removing requires a free command memory slot and will return E_NO_FREE_SLOT if there are currently already MAX_SIMULTANIOUS_COMMANDS ongoing. The command memory slot will be occupied until the callback is invoked.</p>
<p>Even if the publisher is not registered with the service registry (because it was created with register_publisher_unregistered), this function must still be called!</p>
<p>The callback is invoked after the publisher was removed from the service registry, with created set to 0. Since with unregistered publishers this is never the case, the callback is ignored and should be set to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>An operational adapter </td></tr>
    <tr><td class="paramname">publisher</td><td>The publisher to shut down </td></tr>
    <tr><td class="paramname">callback</td><td>For registered publishers only; Invoked after the publisher was removed from the service registry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK or one of the error codes below </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SFSC_OK</td><td>This indicates that unregistering the publisher from the adapter was successfull, and if this publisher is registered in the service registry, that the appropriate command to unregister the publisher from there was issued </td></tr>
    <tr><td class="paramname">E_NO_FREE_SLOT</td><td>There are currently already MAX_SIMULTANIOUS_COMMANDS ongoing </td></tr>
    <tr><td class="paramname">Various</td><td>Network Errors There are serveral other, network-related errors that can occure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f1ce8be8feafb30fc5d182b7384c266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1ce8be8feafb30fc5d182b7384c266">&#9670;&nbsp;</a></span>unregister_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 unregister_server </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__sfsc__server.html">sfsc_server</a> *&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#a9606cb226543c2d13c6d81f6de079326">sfsc_command_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a server. </p>
<p>Unregistering frees the servers server memory slot in the adapter.</p>
<p>The server will be removed from the service registry. Removing requires a free command memory slot and will return E_NO_FREE_SLOT if there are currently already MAX_SIMULTANIOUS_COMMANDS ongoing. The command memory slot will be occupied until the callback is invoked. The callback is invoked after the server was removed from the service registry, with created set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>An operational adapter </td></tr>
    <tr><td class="paramname">server</td><td>The server to shut down </td></tr>
    <tr><td class="paramname">callback</td><td>Invoked after the server was removed from the service registry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK or one of the error codes below </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SFSC_OK</td><td>Indicates that unregistering the server from the adapter was successfull and that the appropriate command to unregister the server from the service registry was issued </td></tr>
    <tr><td class="paramname">E_NO_FREE_SLOT</td><td>There are currently already MAX_SIMULTANIOUS_COMMANDS ongoing </td></tr>
    <tr><td class="paramname">Various</td><td>Network Errors There are serveral other, network-related errors that can occure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addaf3873c9e805b7a3b5ab72c5f59976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaf3873c9e805b7a3b5ab72c5f59976">&#9670;&nbsp;</a></span>unregister_subscriber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 unregister_subscriber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__sfsc__subscriber.html">sfsc_subscriber</a> *&#160;</td>
          <td class="paramname"><em>subscriber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a subscriber and unsubscribe messages on that topic. </p>
<p>If the given subscriber is registered with this adapter to receieve published messages, it will be unregistered and a subscriber memory slot in the adapter will be freed. After this function returns, the callback of the subscriber will not be invoked again.</p>
<p>Unregistering a not registered subscriber will result in a success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>The operational adapter, from which to unregister the subscriber </td></tr>
    <tr><td class="paramname">subscriber</td><td>The subscriber to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK on success or one of the Various Network Errors </dd></dl>

</div>
</div>
<a id="a87bb0e1bf28ae6c6b432f2e3e1e998e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bb0e1bf28ae6c6b432f2e3e1e998e3">&#9670;&nbsp;</a></span>user_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sfsc_int8 user_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *&#160;</td>
          <td class="paramname"><em>adapter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a single system task step on the adapter. </p>
<p>The adapter must be in an operational state, or this call will lead to undefined behaviour.</p>
<p>If this function is called, it will execute callbacks you registered. Whether using blocking or long taking code in your callbacks is allowed or not, depends on your execution modell (see the corresponding section in the readme).</p>
<p>It is important to continue calling this function, even if you entered the user task pause state (mentioned in the documentation of most callback functions).</p>
<p>This function returns an error code, which is SFSC_OK on success. An other return code indicates an error, a list or error codes can be found in sfsc_errors.h and zmtp_states.h. Some errors are recoverable, again, see the readme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>An operational adapter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sfsc_int8 SFSC_OK or an error code </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
