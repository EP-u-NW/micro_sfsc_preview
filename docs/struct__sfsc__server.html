<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MicroSFSC: _sfsc_server Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MicroSFSC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">_sfsc_server Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>State memory for a server service.  
 <a href="struct__sfsc__server.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sfsc__adapter_8h_source.html">sfsc_adapter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:aaf9c7a8fd8363c9beecb93a2598aeb9e"><td class="memItemLeft" align="right" valign="top"><a id="aaf9c7a8fd8363c9beecb93a2598aeb9e"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>on_request</b> )(<a class="el" href="sfsc__adapter_8h.html#ac6d9c7d2592acf83d5140e80d6c2d7b9">sfsc_adapter</a> *adapter, <a class="el" href="struct__sfsc__server.html">sfsc_server</a> *server, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> payload, sfsc_int32 expected_reply_id, <a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a> reply_topic, sfsc_bool *b_auto_advance)</td></tr>
<tr class="separator:aaf9c7a8fd8363c9beecb93a2598aeb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e00f8d04b03655e7cbc36b11521fb5"><td class="memItemLeft" align="right" valign="top"><a id="af9e00f8d04b03655e7cbc36b11521fb5"></a>
sfsc_SfscServiceDescriptor_ServiceTags_ServerTags_AckSettings&#160;</td><td class="memItemRight" valign="bottom"><b>ack_settings</b></td></tr>
<tr class="separator:af9e00f8d04b03655e7cbc36b11521fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92be8c65b0f268fa883bb014fbf19c07"><td class="memItemLeft" align="right" valign="top"><a id="a92be8c65b0f268fa883bb014fbf19c07"></a>
sfsc_SfscId&#160;</td><td class="memItemRight" valign="bottom"><b>service_id</b></td></tr>
<tr class="separator:a92be8c65b0f268fa883bb014fbf19c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52a17ed963a7388350535a64e8d4fa8"><td class="memItemLeft" align="right" valign="top"><a id="ae52a17ed963a7388350535a64e8d4fa8"></a>
<a class="el" href="sfsc__adapter_8h.html#aa436417a69f99cdee2a8eead1ee15adb">sfsc_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>topic</b></td></tr>
<tr class="separator:ae52a17ed963a7388350535a64e8d4fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72184d42b7ba366f47c273a6d43dca75"><td class="memItemLeft" align="right" valign="top"><a id="a72184d42b7ba366f47c273a6d43dca75"></a>
sfsc_bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_channel</b></td></tr>
<tr class="separator:a72184d42b7ba366f47c273a6d43dca75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>State memory for a server service. </p>
<p>To create a server, declare a sfsc_server struct, fill it, and use the register_service function. The sfsc_server struct must be valid until it is unregistered by an call to the unregister_server function.</p>
<p>In constrast to the creating process of a publisher, filling a server is NOT optional.</p>
<p>If you want to choose a service id for the server yourself, you can fill the service_id before registration with an valid 128bit UUID in standard-hexgroup-format (see the random_uuid for more information). Usually, you want to set this field to sfsc_SfscId_init_default (what it already is for any instance initalized with sfsc_server_DEFAULT_INIT) and let the framework automatically generate a service id. After registration, you should not change the value of this field.</p>
<p>If you want to choose a topic for the server yourself you can configure the topic buffer to point to a valid topic. The topic buffer must be valid and immutable (see the sfsc_buffer documentation for more insight on this) as long as the server is registered. If you want the framework to choose a topic for you, set this field to SERVICE_TOPIC_AUTOGEN (what it already is for any instance initalized with sfsc_server_DEFAULT_INIT). To save memory, the framework will then simply use the service_id as topic.</p>
<p>The is_channel field indicates if this server service is a channel service. Channel services do not answer requests with normal binary payload, but answer them with publisher service definitions. Then, the adapter that made the request can subscribe to the publisher and recive values in a streamlike way. After registration, you should not change the value of this field.</p>
<p>The ack_settings field describe this servers acknwoledge strategy: usually, if a server answers a request, the requestor will send back an acknowledge message to the server, so that the server knows that the request was succesfully served. If this acknowledge message does not reach the server after ack_settings.timeout_ms milliseconds, the server will attempt to retransmit the answer, up to ack_settings.send_max_tries times. If ack_settings.send_max_tries is set to 0, this server won't wait for acknowledges and use a fire-and-forget approach. This has some beneficial implications to the answer_request and answer_channel_request functions, documented there. In most cases, using a fire-and-forget approach is valid, since most transmission errors will be corrected on the tcp layer, and a performant sfsc core will rarely drop messages on the zmtp layer.</p>
<p>The on_request callback is invoked every time a request for this server service is receieved. It is allowed to change the on_request callback, even after registering th service. After receiving a request, you will usually take some actions based on the payload and eventually send an answer back to the requestor using the answer_request or answer_channel_request function.</p>
<p>The payload buffer is only valid during the current user task micro step (see the user_task documentation). b_auto_advance is an out-parameter (meaning that you should set it), that lets you pause the user task on the current mirco step: if you set it to 0, you will enter the pause state and the payload pointer will be valid, even after the callback returns. On the other hand, the user task will not advance to the next micro step until you leave the pause state manually (see advance_user_ring).</p>
<p>The expected_reply_id and reply_topic are pull-throught parameters, meaning that you don't need to interact with them, but pass them to the answer_request or answer_channel_request once you want to answer the request. The reply_topic is like the payload also only valid during the current user task micro step.</p>
<p>If you attempt to answer an request right in the callback consider the following: For fire-and-forget servers, this is valid, since the reply_topic you receive by the on_request callback will be passed to the answer_request function, which will return before the on_request callback returns. For non-fire-and-forget servers, this is not valid, since the reply_topic must be valid till the corresonding on_ack call, and not till the answer_request function returns. To work arround this, you can either copy the content of the reply_topic somewhere global (recommended) or pause the user task, until the corresonding on_ack is invoked. Even if the user task is in pause state, the on_ack callback of an answer_request will be invoked, so there will be no deadlock. </p>
</div><hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/sfsc/sfsc_adapter/<a class="el" href="sfsc__adapter_8h_source.html">sfsc_adapter.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
