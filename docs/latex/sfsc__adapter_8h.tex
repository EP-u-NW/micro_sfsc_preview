\hypertarget{sfsc__adapter_8h}{}\doxysection{src/sfsc/sfsc\+\_\+adapter/sfsc\+\_\+adapter.h File Reference}
\label{sfsc__adapter_8h}\index{src/sfsc/sfsc\_adapter/sfsc\_adapter.h@{src/sfsc/sfsc\_adapter/sfsc\_adapter.h}}


Public header that contains all SFSC functions.  


{\ttfamily \#include \char`\"{}../platform/sfsc\+\_\+strings.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}../platform/sfsc\+\_\+types.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}../proto\+\_\+gen/generated.\+pb.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}sfsc\+\_\+adapter\+\_\+config.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}sfsc\+\_\+error\+\_\+codes.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}sfsc\+\_\+states.\+h\char`\"{}}\newline
\doxysubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct__sfsc__adapter__stats}{\+\_\+sfsc\+\_\+adapter\+\_\+stats}}
\begin{DoxyCompactList}\small\item\em The sfsc\+\_\+adapter\+\_\+stats struct contains the infromation needed by the user. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__sfsc__buffer}{\+\_\+sfsc\+\_\+buffer}}
\begin{DoxyCompactList}\small\item\em A simple structure to store binary data and their length. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__sfsc__subscriber}{\+\_\+sfsc\+\_\+subscriber}}
\begin{DoxyCompactList}\small\item\em Struct that contains the necessary state memory to subscribe to a publisher service. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__sfsc__publisher}{\+\_\+sfsc\+\_\+publisher}}
\begin{DoxyCompactList}\small\item\em State memory for a publisher service. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__sfsc__server}{\+\_\+sfsc\+\_\+server}}
\begin{DoxyCompactList}\small\item\em State memory for a server service. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__sfsc__publisher__or__server}{\+\_\+sfsc\+\_\+publisher\+\_\+or\+\_\+server}}
\begin{DoxyCompactList}\small\item\em Container to point either to a sfsc\+\_\+server or sfsc\+\_\+publisher. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__relative__publisher__tags}{\+\_\+relative\+\_\+publisher\+\_\+tags}}
\begin{DoxyCompactList}\small\item\em Represents service tags specific to publisher services. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__relative__server__tags}{\+\_\+relative\+\_\+server\+\_\+tags}}
\begin{DoxyCompactList}\small\item\em Represents service tags specific to server services. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__relative__sfsc__service__descriptor}{\+\_\+relative\+\_\+sfsc\+\_\+service\+\_\+descriptor}}
\begin{DoxyCompactList}\small\item\em Represents all infromation about a service. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__sfsc__channel__answer}{\+\_\+sfsc\+\_\+channel\+\_\+answer}}
\begin{DoxyCompactList}\small\item\em A struct containing all information needed to answer a channel request. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a2151f882f955ef1c4d45431331af71cd}\label{sfsc__adapter_8h_a2151f882f955ef1c4d45431331af71cd}} 
\#define {\bfseries SFSC\+\_\+\+OK}~0
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a8fe828e563b401cfc0d23ddaa9f63bff}\label{sfsc__adapter_8h_a8fe828e563b401cfc0d23ddaa9f63bff}} 
\#define {\bfseries SERVICE\+\_\+\+TYPE\+\_\+\+SERVER}~1
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_ab826d39e60fd00275e2d32b72e6730d2}\label{sfsc__adapter_8h_ab826d39e60fd00275e2d32b72e6730d2}} 
\#define {\bfseries SERVICE\+\_\+\+TYPE\+\_\+\+PUBLISHER}~0
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a9692a0205a857ed2cc29558470c2ed77}\label{sfsc__adapter_8h_a9692a0205a857ed2cc29558470c2ed77}} 
\#define {\bfseries UUID\+\_\+\+LEN}~36
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a2e082e8e08cd3d4193be586b88c248d3}\label{sfsc__adapter_8h_a2e082e8e08cd3d4193be586b88c248d3}} 
\#define {\bfseries sfsc\+\_\+adapter\+\_\+stats\+\_\+\+DEFAULT\+\_\+\+INIT}~    \{ NULL, \{0\}, \{0\}, SFSC\+\_\+\+STATE\+\_\+\+NONE, 0, 0 \}
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a9d55350307413262f8d60fc251253654}\label{sfsc__adapter_8h_a9d55350307413262f8d60fc251253654}} 
\#define {\bfseries sfsc\+\_\+buffer\+\_\+\+DEFAULT\+\_\+\+INIT}~    \{ NULL, 0 \}
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a09b9e118813aed2661b4c7395e788c61}\label{sfsc__adapter_8h_a09b9e118813aed2661b4c7395e788c61}} 
\#define {\bfseries SERVICE\+\_\+\+TOPIC\+\_\+\+AUTOGEN}~sfsc\+\_\+buffer\+\_\+\+DEFAULT\+\_\+\+INIT
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a318024d8a6bab757494760e83309ac38}\label{sfsc__adapter_8h_a318024d8a6bab757494760e83309ac38}} 
\#define {\bfseries sfsc\+\_\+subscriber\+\_\+\+DEFAULT\+\_\+\+INIT}~    \{ sfsc\+\_\+buffer\+\_\+\+DEFAULT\+\_\+\+INIT, NULL \}
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a54bfcf55337681b46b7bf5dda499a97e}\label{sfsc__adapter_8h_a54bfcf55337681b46b7bf5dda499a97e}} 
\#define {\bfseries sfsc\+\_\+publisher\+\_\+\+DEFAULT\+\_\+\+INIT}~    \{ NULL, 0, 0, sfsc\+\_\+\+Sfsc\+Id\+\_\+init\+\_\+default, SERVICE\+\_\+\+TOPIC\+\_\+\+AUTOGEN, 0 \}
\item 
\#define {\bfseries sfsc\+\_\+server\+\_\+\+DEFAULT\+\_\+\+INIT}
\item 
\#define {\bfseries sfsc\+\_\+publisher\+\_\+or\+\_\+server\+\_\+\+INIT\+\_\+\+DEFAULT}
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a572a72066ca9d9eb42efce292f76d762}\label{sfsc__adapter_8h_a572a72066ca9d9eb42efce292f76d762}} 
\#define {\bfseries relative\+\_\+publisher\+\_\+tags\+\_\+\+DEFAULT\+\_\+\+INIT}~    \{ 0, 0, 0, 0, 0 \}
\item 
\#define {\bfseries relative\+\_\+server\+\_\+tags\+\_\+\+DEFAULT\+\_\+\+INIT}
\item 
\#define {\bfseries relative\+\_\+sfsc\+\_\+service\+\_\+descriptor\+\_\+\+DEFAULT\+\_\+\+INIT}
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \+\_\+sfsc\+\_\+adapter \mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}}
\begin{DoxyCompactList}\small\item\em Contains all state memory for a sfsc\+\_\+adapter instance. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{struct__sfsc__adapter__stats}{\+\_\+sfsc\+\_\+adapter\+\_\+stats}} \mbox{\hyperlink{sfsc__adapter_8h_a67512c6ef1c1f7e2e9cd669f21ec1d1b}{sfsc\+\_\+adapter\+\_\+stats}}
\begin{DoxyCompactList}\small\item\em The sfsc\+\_\+adapter\+\_\+stats struct contains the infromation needed by the user. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{struct__sfsc__buffer}{\+\_\+sfsc\+\_\+buffer}} \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}
\begin{DoxyCompactList}\small\item\em A simple structure to store binary data and their length. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{sfsc__adapter_8h_af1c5e96d40d0a470c1bb17ec95e6c1a8}\label{sfsc__adapter_8h_af1c5e96d40d0a470c1bb17ec95e6c1a8}} 
typedef struct \mbox{\hyperlink{struct__sfsc__subscriber}{\+\_\+sfsc\+\_\+subscriber}} {\bfseries sfsc\+\_\+subscriber}
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a78b6f781bf44962e1eab022433843905}\label{sfsc__adapter_8h_a78b6f781bf44962e1eab022433843905}} 
typedef struct \mbox{\hyperlink{struct__sfsc__publisher}{\+\_\+sfsc\+\_\+publisher}} {\bfseries sfsc\+\_\+publisher}
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a69d1c1ad55e278e92e9514aaa203c621}\label{sfsc__adapter_8h_a69d1c1ad55e278e92e9514aaa203c621}} 
typedef struct \mbox{\hyperlink{struct__sfsc__server}{\+\_\+sfsc\+\_\+server}} {\bfseries sfsc\+\_\+server}
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a20edc615456e83ca1e18c459170457ac}\label{sfsc__adapter_8h_a20edc615456e83ca1e18c459170457ac}} 
typedef struct \mbox{\hyperlink{struct__sfsc__publisher__or__server}{\+\_\+sfsc\+\_\+publisher\+\_\+or\+\_\+server}} \mbox{\hyperlink{sfsc__adapter_8h_a20edc615456e83ca1e18c459170457ac}{sfsc\+\_\+publisher\+\_\+or\+\_\+server}}
\begin{DoxyCompactList}\small\item\em Container to point either to a sfsc\+\_\+server or sfsc\+\_\+publisher. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{struct__relative__publisher__tags}{\+\_\+relative\+\_\+publisher\+\_\+tags}} \mbox{\hyperlink{sfsc__adapter_8h_aed6ed5b87f6873abc3f42183d6c80f8e}{relative\+\_\+publisher\+\_\+tags}}
\begin{DoxyCompactList}\small\item\em Represents service tags specific to publisher services. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{struct__relative__server__tags}{\+\_\+relative\+\_\+server\+\_\+tags}} \mbox{\hyperlink{sfsc__adapter_8h_a6867fb92cb6c9853b21b0110a208cf60}{relative\+\_\+server\+\_\+tags}}
\begin{DoxyCompactList}\small\item\em Represents service tags specific to server services. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{struct__relative__sfsc__service__descriptor}{\+\_\+relative\+\_\+sfsc\+\_\+service\+\_\+descriptor}} \mbox{\hyperlink{sfsc__adapter_8h_a8734edf2cb2e03719e603dec6c2d049f}{relative\+\_\+sfsc\+\_\+service\+\_\+descriptor}}
\begin{DoxyCompactList}\small\item\em Represents all infromation about a service. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{struct__sfsc__channel__answer}{\+\_\+sfsc\+\_\+channel\+\_\+answer}} \mbox{\hyperlink{sfsc__adapter_8h_a487711a208cf17fd8d171031dae258f8}{sfsc\+\_\+channel\+\_\+answer}}
\begin{DoxyCompactList}\small\item\em A struct containing all information needed to answer a channel request. \end{DoxyCompactList}\item 
typedef void() \mbox{\hyperlink{sfsc__adapter_8h_a9606cb226543c2d13c6d81f6de079326}{sfsc\+\_\+command\+\_\+callback}}(\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{sfsc__adapter_8h_a20edc615456e83ca1e18c459170457ac}{sfsc\+\_\+publisher\+\_\+or\+\_\+server}} service, sfsc\+\_\+bool created)
\begin{DoxyCompactList}\small\item\em Called when a command to create or delete a service succeeds. \end{DoxyCompactList}\item 
typedef void() \mbox{\hyperlink{sfsc__adapter_8h_a45d55712718b8b83acf89e41f66134c2}{sfsc\+\_\+query\+\_\+callback}}(\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{sfsc__adapter_8h_a8734edf2cb2e03719e603dec6c2d049f}{relative\+\_\+sfsc\+\_\+service\+\_\+descriptor}} descriptor, sfsc\+\_\+uint8 $\ast$offset, sfsc\+\_\+size length, sfsc\+\_\+bool is\+\_\+last)
\begin{DoxyCompactList}\small\item\em Called during a query process with a service descriptor, or to indicate that the query process is done. \end{DoxyCompactList}\item 
typedef void() \mbox{\hyperlink{sfsc__adapter_8h_a1969b502e38168910b9e57d952369316}{sfsc\+\_\+request\+\_\+callback}}(\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} payload, sfsc\+\_\+bool timeout, void $\ast$mapping\+\_\+arg, sfsc\+\_\+bool $\ast$b\+\_\+auto\+\_\+advance)
\begin{DoxyCompactList}\small\item\em Invoked when an answer to a request is receieved, or when the request times out. \end{DoxyCompactList}\item 
typedef void() \mbox{\hyperlink{sfsc__adapter_8h_a1497b54b1ae44a7cac6fb4f93a8217da}{sfsc\+\_\+channel\+\_\+request\+\_\+callback}}(\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, sfsc\+\_\+bool timeout, sfsc\+\_\+int8 decode\+\_\+error, \mbox{\hyperlink{sfsc__adapter_8h_a8734edf2cb2e03719e603dec6c2d049f}{relative\+\_\+sfsc\+\_\+service\+\_\+descriptor}} $\ast$descriptor, sfsc\+\_\+uint8 $\ast$descirptor\+\_\+offset, sfsc\+\_\+size descirptor\+\_\+length, void $\ast$mapping\+\_\+arg, sfsc\+\_\+bool $\ast$b\+\_\+auto\+\_\+advance)
\begin{DoxyCompactList}\small\item\em Invoked when an answer to a channel request is receieved, or when the request times out. \end{DoxyCompactList}\item 
typedef void() \mbox{\hyperlink{sfsc__adapter_8h_aaaee1dca7def711316b62f037165b3e0}{sfsc\+\_\+answer\+\_\+ack\+\_\+callback}}(\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__server}{sfsc\+\_\+server}} $\ast$server, sfsc\+\_\+bool timeout, void $\ast$mapping\+\_\+arg)
\begin{DoxyCompactList}\small\item\em Invoked if an ack message for an answer was receieved, or the servers timeout condition was meet. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{sfsc__adapter_8h_a67512c6ef1c1f7e2e9cd669f21ec1d1b}{sfsc\+\_\+adapter\+\_\+stats}} $\ast$ \mbox{\hyperlink{sfsc__adapter_8h_acea1c001c6a80d2a3109aedd11232f29}{adapter\+\_\+stats}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter)
\begin{DoxyCompactList}\small\item\em Recommended way to access the stats of an adapter. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_ab6bd4332c56b21f6b9ce25c80eadbde4}{start\+\_\+session\+\_\+bootstraped}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, const char $\ast$address, int original\+\_\+control\+\_\+pub\+\_\+port)
\begin{DoxyCompactList}\small\item\em Starts a sfsc adapter session with bootstraping. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_a478abd5351cea939fd22e21ba976f97a}{start\+\_\+session}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, const char $\ast$address, int original\+\_\+control\+\_\+pub\+\_\+port, int original\+\_\+control\+\_\+sub\+\_\+port, int original\+\_\+data\+\_\+pub\+\_\+port, int original\+\_\+data\+\_\+sub\+\_\+port)
\begin{DoxyCompactList}\small\item\em Stats a sfsc adapter session without bootstraping. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_ac826d18cb2e8ffff9d1651cfe4a95df3}{release\+\_\+session}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter)
\begin{DoxyCompactList}\small\item\em Releases the sockets associated with an adapter. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_a907e055e091da55aee6ea185f042bd30}{register\+\_\+subscriber}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__subscriber}{sfsc\+\_\+subscriber}} $\ast$subscriber)
\begin{DoxyCompactList}\small\item\em Subscribes to a sfsc publisher through the given adapter. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_addaf3873c9e805b7a3b5ab72c5f59976}{unregister\+\_\+subscriber}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__subscriber}{sfsc\+\_\+subscriber}} $\ast$subscriber)
\begin{DoxyCompactList}\small\item\em Unregisters a subscriber and unsubscribe messages on that topic. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_a4e1311fbc5ccafdc40d075390ac1db62}{query\+\_\+services}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{sfsc__adapter_8h_a45d55712718b8b83acf89e41f66134c2}{sfsc\+\_\+query\+\_\+callback}} $\ast$on\+\_\+service)
\begin{DoxyCompactList}\small\item\em Starts a query process to obtain registered services from the core. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sfsc__adapter_8h_abe50351d6b8d32fc7e8b52a63163cc6b}{query\+\_\+services\+\_\+next}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, sfsc\+\_\+bool next)
\begin{DoxyCompactList}\small\item\em Tells the framework to continue or to end a currently ongoing query process. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_a36e54333c8c4c5cfe295c474953ea0b9}{register\+\_\+publisher}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__publisher}{sfsc\+\_\+publisher}} $\ast$publisher, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} name, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} custom\+\_\+tags, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} output\+\_\+message\+\_\+type, \mbox{\hyperlink{sfsc__adapter_8h_a9606cb226543c2d13c6d81f6de079326}{sfsc\+\_\+command\+\_\+callback}} $\ast$command\+\_\+callback)
\begin{DoxyCompactList}\small\item\em Sets up a publisher service and registers it with the core. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_a9f3a86f49777fbd148d95c724c568bdb}{register\+\_\+publisher\+\_\+unregistered}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__publisher}{sfsc\+\_\+publisher}} $\ast$publisher)
\begin{DoxyCompactList}\small\item\em Sets up a publisher you can publish with, but does not register it in the cores service registry. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_ac62616aff23fe7cac25ed256ce4e200e}{unregister\+\_\+publisher}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__publisher}{sfsc\+\_\+publisher}} $\ast$publisher, \mbox{\hyperlink{sfsc__adapter_8h_a9606cb226543c2d13c6d81f6de079326}{sfsc\+\_\+command\+\_\+callback}} $\ast$command\+\_\+callback)
\begin{DoxyCompactList}\small\item\em Unregisters a publisher. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_a1a971fb6b660a3400b6bc6fd072586e0}{publish}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__publisher}{sfsc\+\_\+publisher}} $\ast$publisher, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} payload)
\begin{DoxyCompactList}\small\item\em Publishes data through a publisher. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_ac1ed1601a750a283cabb2993cb61c29d}{request}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} topic, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} payload, sfsc\+\_\+uint64 timeout\+\_\+time, \mbox{\hyperlink{sfsc__adapter_8h_a1969b502e38168910b9e57d952369316}{sfsc\+\_\+request\+\_\+callback}} $\ast$on\+\_\+answer, void $\ast$mapping\+\_\+arg)
\begin{DoxyCompactList}\small\item\em Makes a request call to a server service. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_a1591f2771368859f7c8980dde2c73e34}{channel\+\_\+request}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} topic, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} payload, sfsc\+\_\+uint64 timeout\+\_\+time, \mbox{\hyperlink{sfsc__adapter_8h_a8734edf2cb2e03719e603dec6c2d049f}{relative\+\_\+sfsc\+\_\+service\+\_\+descriptor}} $\ast$descriptor, sfsc\+\_\+uint8 $\ast$descriptor\+\_\+space, sfsc\+\_\+size descriptor\+\_\+space\+\_\+lenght, \mbox{\hyperlink{sfsc__adapter_8h_a1497b54b1ae44a7cac6fb4f93a8217da}{sfsc\+\_\+channel\+\_\+request\+\_\+callback}} $\ast$on\+\_\+answer, void $\ast$mapping\+\_\+arg)
\begin{DoxyCompactList}\small\item\em Makes a request call to a channel server service. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_ab548429c2d440ec47260c2cc69a288cd}{register\+\_\+server}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__server}{sfsc\+\_\+server}} $\ast$server, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} name, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} custom\+\_\+tags, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} output\+\_\+message\+\_\+type, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} input\+\_\+message\+\_\+type, \mbox{\hyperlink{sfsc__adapter_8h_a9606cb226543c2d13c6d81f6de079326}{sfsc\+\_\+command\+\_\+callback}} $\ast$command\+\_\+callback)
\begin{DoxyCompactList}\small\item\em Sets up a server service and registers it with the core. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_aa064ef0413ec5d1e8e391ad81dcf9ef6}{unregister\+\_\+server}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__server}{sfsc\+\_\+server}} $\ast$server, \mbox{\hyperlink{sfsc__adapter_8h_a9606cb226543c2d13c6d81f6de079326}{sfsc\+\_\+command\+\_\+callback}} $\ast$command\+\_\+callback)
\begin{DoxyCompactList}\small\item\em Unregisters a server. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_a03acde575324406f3d90b1196b097f5f}{answer\+\_\+request}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__server}{sfsc\+\_\+server}} $\ast$server, sfsc\+\_\+int32 expected\+\_\+reply\+\_\+id, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} reply\+\_\+topic, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} $\ast$payload, void $\ast$mapping\+\_\+arg, \mbox{\hyperlink{sfsc__adapter_8h_aaaee1dca7def711316b62f037165b3e0}{sfsc\+\_\+answer\+\_\+ack\+\_\+callback}} $\ast$on\+\_\+ack)
\begin{DoxyCompactList}\small\item\em Answers a request. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_a36faef0ff0e5f45340846237e56f81d9}{answer\+\_\+channel\+\_\+request}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__server}{sfsc\+\_\+server}} $\ast$server, sfsc\+\_\+int32 expected\+\_\+reply\+\_\+id, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} reply\+\_\+topic, \mbox{\hyperlink{sfsc__adapter_8h_a487711a208cf17fd8d171031dae258f8}{sfsc\+\_\+channel\+\_\+answer}} $\ast$channel\+\_\+answer, void $\ast$mapping\+\_\+arg, \mbox{\hyperlink{sfsc__adapter_8h_aaaee1dca7def711316b62f037165b3e0}{sfsc\+\_\+answer\+\_\+ack\+\_\+callback}} $\ast$on\+\_\+ack)
\begin{DoxyCompactList}\small\item\em Used to answer a channel request. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sfsc__adapter_8h_adb7e6ee6ba9c8bf9a8bd3f6874887019}{random\+\_\+uuid}} (sfsc\+\_\+uint8 target\mbox{[}UUID\+\_\+\+LEN\mbox{]})
\begin{DoxyCompactList}\small\item\em Generates and writes a random 128bit UUID in standard-\/hexgroup-\/format to the target buffer. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_ada689902e1addaeb4a999c775c6705d0}{system\+\_\+task}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter)
\begin{DoxyCompactList}\small\item\em Executes a single system task step on the adapter. \end{DoxyCompactList}\item 
sfsc\+\_\+int8 \mbox{\hyperlink{sfsc__adapter_8h_a87bb0e1bf28ae6c6b432f2e3e1e998e3}{user\+\_\+task}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter)
\begin{DoxyCompactList}\small\item\em Executes a single system task step on the adapter. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sfsc__adapter_8h_adecc1c0af790d4a51d7b196ed1c076e5}{advance\+\_\+user\+\_\+ring}} (\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter)
\begin{DoxyCompactList}\small\item\em Leaves the user task pause state. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_a2f03655571bf3e74f2103b780496cf88}\label{sfsc__adapter_8h_a2f03655571bf3e74f2103b780496cf88}} 
const \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} {\bfseries sfsc\+\_\+buffer\+\_\+default}
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_ab32b1c3a552cfe42de102d6843f05f26}\label{sfsc__adapter_8h_ab32b1c3a552cfe42de102d6843f05f26}} 
const \mbox{\hyperlink{sfsc__adapter_8h_aed6ed5b87f6873abc3f42183d6c80f8e}{relative\+\_\+publisher\+\_\+tags}} {\bfseries relative\+\_\+publisher\+\_\+tags\+\_\+default}
\item 
\mbox{\Hypertarget{sfsc__adapter_8h_ae541739bb6f1831887f39b700a35169a}\label{sfsc__adapter_8h_ae541739bb6f1831887f39b700a35169a}} 
const \mbox{\hyperlink{sfsc__adapter_8h_a6867fb92cb6c9853b21b0110a208cf60}{relative\+\_\+server\+\_\+tags}} {\bfseries relative\+\_\+server\+\_\+tags\+\_\+default}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Public header that contains all SFSC functions. 



\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{sfsc__adapter_8h_a5ebc0df905bb8a68a896b627de7ede46}\label{sfsc__adapter_8h_a5ebc0df905bb8a68a896b627de7ede46}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!relative\_server\_tags\_DEFAULT\_INIT@{relative\_server\_tags\_DEFAULT\_INIT}}
\index{relative\_server\_tags\_DEFAULT\_INIT@{relative\_server\_tags\_DEFAULT\_INIT}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{relative\_server\_tags\_DEFAULT\_INIT}{relative\_server\_tags\_DEFAULT\_INIT}}
{\footnotesize\ttfamily \#define relative\+\_\+server\+\_\+tags\+\_\+\+DEFAULT\+\_\+\+INIT}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \{                                                                                  \(\backslash\)}
\DoxyCodeLine{        0, 0, 0, 0, 0, 0,                                                              \(\backslash\)}
\DoxyCodeLine{            sfsc\_SfscServiceDescriptor\_ServiceTags\_ServerTags\_AckSettings\_init\_default \(\backslash\)}
\DoxyCodeLine{    \}}

\end{DoxyCode}
\mbox{\Hypertarget{sfsc__adapter_8h_ac641beceb65f33378234a9853e0d34d9}\label{sfsc__adapter_8h_ac641beceb65f33378234a9853e0d34d9}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!relative\_sfsc\_service\_descriptor\_DEFAULT\_INIT@{relative\_sfsc\_service\_descriptor\_DEFAULT\_INIT}}
\index{relative\_sfsc\_service\_descriptor\_DEFAULT\_INIT@{relative\_sfsc\_service\_descriptor\_DEFAULT\_INIT}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{relative\_sfsc\_service\_descriptor\_DEFAULT\_INIT}{relative\_sfsc\_service\_descriptor\_DEFAULT\_INIT}}
{\footnotesize\ttfamily \#define relative\+\_\+sfsc\+\_\+service\+\_\+descriptor\+\_\+\+DEFAULT\+\_\+\+INIT}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \{                                                                       \(\backslash\)}
\DoxyCodeLine{        sfsc\_SfscId\_init\_default, sfsc\_SfscId\_init\_default,                 \(\backslash\)}
\DoxyCodeLine{            sfsc\_SfscId\_init\_default, 0, 0, 0, 0, SERVICE\_TYPE\_PUBLISHER, \{ \(\backslash\)}
\DoxyCodeLine{            relative\_publisher\_tags\_DEFAULT\_INIT                            \(\backslash\)}
\DoxyCodeLine{        \}                                                                   \(\backslash\)}
\DoxyCodeLine{    \}}

\end{DoxyCode}
\mbox{\Hypertarget{sfsc__adapter_8h_a80575cdc4a52860d99c683d641dfc8c9}\label{sfsc__adapter_8h_a80575cdc4a52860d99c683d641dfc8c9}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!sfsc\_publisher\_or\_server\_INIT\_DEFAULT@{sfsc\_publisher\_or\_server\_INIT\_DEFAULT}}
\index{sfsc\_publisher\_or\_server\_INIT\_DEFAULT@{sfsc\_publisher\_or\_server\_INIT\_DEFAULT}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{sfsc\_publisher\_or\_server\_INIT\_DEFAULT}{sfsc\_publisher\_or\_server\_INIT\_DEFAULT}}
{\footnotesize\ttfamily \#define sfsc\+\_\+publisher\+\_\+or\+\_\+server\+\_\+\+INIT\+\_\+\+DEFAULT}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \{                                         \(\backslash\)}
\DoxyCodeLine{        0, \{ NULL \}                           \(\backslash\)}
\DoxyCodeLine{    \}}

\end{DoxyCode}
\mbox{\Hypertarget{sfsc__adapter_8h_a743d1b07a52012e2f58d3762fd751288}\label{sfsc__adapter_8h_a743d1b07a52012e2f58d3762fd751288}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!sfsc\_server\_DEFAULT\_INIT@{sfsc\_server\_DEFAULT\_INIT}}
\index{sfsc\_server\_DEFAULT\_INIT@{sfsc\_server\_DEFAULT\_INIT}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{sfsc\_server\_DEFAULT\_INIT}{sfsc\_server\_DEFAULT\_INIT}}
{\footnotesize\ttfamily \#define sfsc\+\_\+server\+\_\+\+DEFAULT\+\_\+\+INIT}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \{                                                                                   \(\backslash\)}
\DoxyCodeLine{        NULL,                                                                           \(\backslash\)}
\DoxyCodeLine{            sfsc\_SfscServiceDescriptor\_ServiceTags\_ServerTags\_AckSettings\_init\_default, \(\backslash\)}
\DoxyCodeLine{            sfsc\_SfscId\_init\_default, SERVICE\_TOPIC\_AUTOGEN, 0                          \(\backslash\)}
\DoxyCodeLine{    \}}

\end{DoxyCode}


\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{sfsc__adapter_8h_aed6ed5b87f6873abc3f42183d6c80f8e}\label{sfsc__adapter_8h_aed6ed5b87f6873abc3f42183d6c80f8e}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!relative\_publisher\_tags@{relative\_publisher\_tags}}
\index{relative\_publisher\_tags@{relative\_publisher\_tags}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{relative\_publisher\_tags}{relative\_publisher\_tags}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{struct__relative__publisher__tags}{\+\_\+relative\+\_\+publisher\+\_\+tags}} \mbox{\hyperlink{sfsc__adapter_8h_aed6ed5b87f6873abc3f42183d6c80f8e}{relative\+\_\+publisher\+\_\+tags}}}



Represents service tags specific to publisher services. 

The format and idea of the fields is very similar to relative\+\_\+sfsc\+\_\+service\+\_\+descriptor, see there for an explanation.

An exception to this is the unregistered field. See the sfsc\+\_\+publisher struct documentation for an explanation. \mbox{\Hypertarget{sfsc__adapter_8h_a6867fb92cb6c9853b21b0110a208cf60}\label{sfsc__adapter_8h_a6867fb92cb6c9853b21b0110a208cf60}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!relative\_server\_tags@{relative\_server\_tags}}
\index{relative\_server\_tags@{relative\_server\_tags}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{relative\_server\_tags}{relative\_server\_tags}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{struct__relative__server__tags}{\+\_\+relative\+\_\+server\+\_\+tags}} \mbox{\hyperlink{sfsc__adapter_8h_a6867fb92cb6c9853b21b0110a208cf60}{relative\+\_\+server\+\_\+tags}}}



Represents service tags specific to server services. 

The format and idea of the fields is very similar to relative\+\_\+sfsc\+\_\+service\+\_\+descriptor, see there for an explanation.

An exception to this is the ack\+\_\+settings field. See the sfsc\+\_\+server struct documentation for an explanation. \mbox{\Hypertarget{sfsc__adapter_8h_a8734edf2cb2e03719e603dec6c2d049f}\label{sfsc__adapter_8h_a8734edf2cb2e03719e603dec6c2d049f}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!relative\_sfsc\_service\_descriptor@{relative\_sfsc\_service\_descriptor}}
\index{relative\_sfsc\_service\_descriptor@{relative\_sfsc\_service\_descriptor}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{relative\_sfsc\_service\_descriptor}{relative\_sfsc\_service\_descriptor}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{struct__relative__sfsc__service__descriptor}{\+\_\+relative\+\_\+sfsc\+\_\+service\+\_\+descriptor}} \mbox{\hyperlink{sfsc__adapter_8h_a8734edf2cb2e03719e603dec6c2d049f}{relative\+\_\+sfsc\+\_\+service\+\_\+descriptor}}}



Represents all infromation about a service. 

A relative\+\_\+sfsc\+\_\+service\+\_\+descriptor is relative because it does not contain information about a service directly, but it merely serves as an index structure. The indexes (which end with \+\_\+offset) are relative to a memory area. The memory areas address (called start in the following) is usually delivered with the descriptor. For example, to now access the name of the service, read name\+\_\+len bytes from (start+name\+\_\+offset). For reasoning, why this relative apporach is used, read the last paragraph.

An exception to the above are the core\+\_\+id, adapter\+\_\+id, and service\+\_\+id fields, which actually contain the respective ids, and thereby denote the core and adapter this service belongs to, as well as this services own id.

The service\+\_\+type field is either SERVICE\+\_\+\+TYPE\+\_\+\+SERVER or SERVICE\+\_\+\+TYPE\+\_\+\+PUBLISHER and indicates, how the service\+\_\+tags union should be treated.

Why is this relative approach used? The binary size of a serivce in sfsc is not limited, so we can not know the size of the respective service fields in advance. On the other hand, this framework does not use dynamic memory allocation (malloc). A possible solution is to statically allocate memory for each field and add an length field, to indicate, how much memory is actually used. The difference between the allocated and actually used size is called waste. Instead of allocation a memory area for each field, we use one bigger memory area for all fields. The idea is that, because of the indivudual waste, this single field size can be smaller then sum of all indivudual field sizes, while still containing enough space to store all necessary information. \mbox{\Hypertarget{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}\label{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!sfsc\_adapter@{sfsc\_adapter}}
\index{sfsc\_adapter@{sfsc\_adapter}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{sfsc\_adapter}{sfsc\_adapter}}
{\footnotesize\ttfamily typedef struct \+\_\+sfsc\+\_\+adapter \mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}}}



Contains all state memory for a sfsc\+\_\+adapter instance. 

In most cases, you do not need to interact with the fields of a sfsc\+\_\+adapter struct directly. Therefor, the struct members are not exposed in this header. The for you relevant fields should be accessed throught the adapter\+\_\+stats function.

Note however, that the compilation unit declaring the sfsc\+\_\+adapter struct needs a full specification of it. Only this compilation unit should include sfsc\+\_\+adapter\+\_\+struct.\+h. \mbox{\Hypertarget{sfsc__adapter_8h_a67512c6ef1c1f7e2e9cd669f21ec1d1b}\label{sfsc__adapter_8h_a67512c6ef1c1f7e2e9cd669f21ec1d1b}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!sfsc\_adapter\_stats@{sfsc\_adapter\_stats}}
\index{sfsc\_adapter\_stats@{sfsc\_adapter\_stats}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{sfsc\_adapter\_stats}{sfsc\_adapter\_stats}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{struct__sfsc__adapter__stats}{\+\_\+sfsc\+\_\+adapter\+\_\+stats}} \mbox{\hyperlink{sfsc__adapter_8h_a67512c6ef1c1f7e2e9cd669f21ec1d1b}{sfsc\+\_\+adapter\+\_\+stats}}}



The sfsc\+\_\+adapter\+\_\+stats struct contains the infromation needed by the user. 

The stats of an adapter should be accessd throught the adapter\+\_\+stats function. The fields of this struct are all read-\/only and should not be modified by you.

The address field specifies the address of the core and is implicitly set by you during the start\+\_\+session\+\_\+bootstraped or start\+\_\+session functions. The format of the address is up to you and can be anything, as long it is understood by your implementation of socket\+\_\+connect (see sfsc\+\_\+sockets.\+h).

The adapter\+\_\+id and core\+\_\+id fields indicate this adapters id and the id of the core it is connected to respectivly. They are both filled during the handshake, and ready to use once the adapters state is operational.

The state indicates to current connection state of an adapter. The various states are defined in sfsc\+\_\+states.\+h and are all prefixed with SFSC\+\_\+\+STATE\+\_\+. An adapter is considered operational if the value of this field is $>$= SFSC\+\_\+\+STATE\+\_\+\+OPERATIONAL.

Due to the execution and memory model of this framework it can occur that some messages receieved from the network are dropped (see the system\+\_\+task function for details). The discarded\+\_\+message\+\_\+count keeps track of the number of lost messages.

The query\+\_\+in\+\_\+progress is set to 1 if you started a query process using query\+\_\+services, and will be reset to 0 if the query process is terminated. See the query functions for more information. \mbox{\Hypertarget{sfsc__adapter_8h_aaaee1dca7def711316b62f037165b3e0}\label{sfsc__adapter_8h_aaaee1dca7def711316b62f037165b3e0}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!sfsc\_answer\_ack\_callback@{sfsc\_answer\_ack\_callback}}
\index{sfsc\_answer\_ack\_callback@{sfsc\_answer\_ack\_callback}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{sfsc\_answer\_ack\_callback}{sfsc\_answer\_ack\_callback}}
{\footnotesize\ttfamily typedef void() sfsc\+\_\+answer\+\_\+ack\+\_\+callback(\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{struct__sfsc__server}{sfsc\+\_\+server}} $\ast$server, sfsc\+\_\+bool timeout, void $\ast$mapping\+\_\+arg)}



Invoked if an ack message for an answer was receieved, or the servers timeout condition was meet. 

If timeout is set to 1 all retransmission attempts failed (see the sfsc\+\_\+server.\+ack\+\_\+settings), if it is set to 0, the requestor acknowledged the answer.

The mapping\+\_\+arg parameter is a mapping-\/argument (explained in the request functions documentation with an example). \mbox{\Hypertarget{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}\label{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!sfsc\_buffer@{sfsc\_buffer}}
\index{sfsc\_buffer@{sfsc\_buffer}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{sfsc\_buffer}{sfsc\_buffer}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{struct__sfsc__buffer}{\+\_\+sfsc\+\_\+buffer}} \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}



A simple structure to store binary data and their length. 

This structure type is widely used in the framework for compact data storing. It is important to notice that some functions will take a sfsc\+\_\+buffer struct as parameter directly, while others will work with pointers. In the most cases, this says something about the mutality of the content.

In general, for the use-\/time of a sfsc\+\_\+buffer (usually defined in the respective functions documentation), the memory area the buffer points to must be valid and of the in the struct specified length.

When passing the struct to a function, it must be immutable, meaning that for the use-\/time of the sfsc\+\_\+buffer, the content must not change.

When passing a pointer to a function, the content is allowed to be mutable, meaning that during the use-\/time of the sfsc\+\_\+buffer, you are allowed to change the content pointer and thereby change the memory area are this sfsc\+\_\+buffer is backed by. If you do so, don\textquotesingle{}t forget to update the length field accordingly. \mbox{\Hypertarget{sfsc__adapter_8h_a487711a208cf17fd8d171031dae258f8}\label{sfsc__adapter_8h_a487711a208cf17fd8d171031dae258f8}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!sfsc\_channel\_answer@{sfsc\_channel\_answer}}
\index{sfsc\_channel\_answer@{sfsc\_channel\_answer}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{sfsc\_channel\_answer}{sfsc\_channel\_answer}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{struct__sfsc__channel__answer}{\+\_\+sfsc\+\_\+channel\+\_\+answer}} \mbox{\hyperlink{sfsc__adapter_8h_a487711a208cf17fd8d171031dae258f8}{sfsc\+\_\+channel\+\_\+answer}}}



A struct containing all information needed to answer a channel request. 

Instead of normal binary payload, a channel request is answered with the definition of a publisher service.

The core\+\_\+id, adapter\+\_\+id and service\+\_\+id represent the core and adapter the publisher service is conencted to, as well as the publisher service itself. Their length must be UUID\+\_\+\+LEN and their format must be standard-\/hexgroup-\/format (see the random\+\_\+uuid function). The reason a sfsc\+\_\+channel\+\_\+answer uses sfsc\+\_\+uint8$\ast$ instead of sfsc\+\_\+uint8\mbox{[}\mbox{]} is to remove copying and to save memory\+: The publisher you are describing is most likly hosted by the same adapter that will send this channel answer. Instead of allocating 3$\ast$\+UUID\+\_\+\+LEN memory and copy the details from the adapter to the sfsc\+\_\+channel\+\_\+answer, you can just let the fields point to \&adapter\+\_\+states()-\/$>$core\+\_\+id and \&adapter\+\_\+states()-\/$>$adapter\+\_\+id respectivly.

All sfsc\+\_\+buffers must be valid during the use-\/time of the sfsc\+\_\+channel\+\_\+answer struct and are optional. If publisher\+\_\+output\+\_\+topic is set to SERVICE\+\_\+\+TOPIC\+\_\+\+AUTOGEN the topic autogenerate rule (as described in sfsc\+\_\+publisher) will be applied, and the service\+\_\+id will be used as topic.

The unregistered should be set to 0 if the publisher you are describing in this sfsc\+\_\+channel\+\_\+answer is also registered in the service registry, or to 1 if it is not. \mbox{\Hypertarget{sfsc__adapter_8h_a1497b54b1ae44a7cac6fb4f93a8217da}\label{sfsc__adapter_8h_a1497b54b1ae44a7cac6fb4f93a8217da}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!sfsc\_channel\_request\_callback@{sfsc\_channel\_request\_callback}}
\index{sfsc\_channel\_request\_callback@{sfsc\_channel\_request\_callback}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{sfsc\_channel\_request\_callback}{sfsc\_channel\_request\_callback}}
{\footnotesize\ttfamily typedef void() sfsc\+\_\+channel\+\_\+request\+\_\+callback(\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, sfsc\+\_\+bool timeout, sfsc\+\_\+int8 decode\+\_\+error, \mbox{\hyperlink{sfsc__adapter_8h_a8734edf2cb2e03719e603dec6c2d049f}{relative\+\_\+sfsc\+\_\+service\+\_\+descriptor}} $\ast$descriptor, sfsc\+\_\+uint8 $\ast$descirptor\+\_\+offset, sfsc\+\_\+size descirptor\+\_\+length, void $\ast$mapping\+\_\+arg, sfsc\+\_\+bool $\ast$b\+\_\+auto\+\_\+advance)}



Invoked when an answer to a channel request is receieved, or when the request times out. 

The timeout parameter is set to 1 if the callback invokation is caused by a timeout, to 0 if an answer is deleivered.

The mapping\+\_\+arg parameter is a mapping-\/argument (explained in the request functions documentation with an example).

If decode\+\_\+error is not SFSC\+\_\+\+OK, an error occured during decoding the received service definition. This will most likley happen due to a too small memory area for the descriptor. In this case decode\+\_\+error is set to E\+\_\+\+BUFFER\+\_\+\+INSUFFICIENT, and descirptor\+\_\+length indicates, how much memory would have been needed.

In contrast to the payload in a normal sfsc\+\_\+request\+\_\+callback, you have allocated the descriptor struct and the descriptor memory area yourself, so they will be valid until you do something with them, and won\textquotesingle{}t become invalid once the callback returns. Thus, the b\+\_\+auto\+\_\+advance does not influence the validity, and is just there as a convenience tool to enter the user task pause state (see the user\+\_\+task documentation). \mbox{\Hypertarget{sfsc__adapter_8h_a9606cb226543c2d13c6d81f6de079326}\label{sfsc__adapter_8h_a9606cb226543c2d13c6d81f6de079326}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!sfsc\_command\_callback@{sfsc\_command\_callback}}
\index{sfsc\_command\_callback@{sfsc\_command\_callback}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{sfsc\_command\_callback}{sfsc\_command\_callback}}
{\footnotesize\ttfamily typedef void() sfsc\+\_\+command\+\_\+callback(\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{sfsc__adapter_8h_a20edc615456e83ca1e18c459170457ac}{sfsc\+\_\+publisher\+\_\+or\+\_\+server}} service, sfsc\+\_\+bool created)}



Called when a command to create or delete a service succeeds. 

A create command means that the service was registered in the cores event-\/log, a delete command means taht the service was unregistred from it.


\begin{DoxyParams}{Parameters}
{\em adapter} & the executing adapter \\
\hline
{\em service} & a struct describing the service \\
\hline
{\em created} & 1 if the command was a create command, 0 if it was a delete command \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{sfsc__adapter_8h_a45d55712718b8b83acf89e41f66134c2}\label{sfsc__adapter_8h_a45d55712718b8b83acf89e41f66134c2}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!sfsc\_query\_callback@{sfsc\_query\_callback}}
\index{sfsc\_query\_callback@{sfsc\_query\_callback}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{sfsc\_query\_callback}{sfsc\_query\_callback}}
{\footnotesize\ttfamily typedef void() sfsc\+\_\+query\+\_\+callback(\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{sfsc__adapter_8h_a8734edf2cb2e03719e603dec6c2d049f}{relative\+\_\+sfsc\+\_\+service\+\_\+descriptor}} descriptor, sfsc\+\_\+uint8 $\ast$offset, sfsc\+\_\+size length, sfsc\+\_\+bool is\+\_\+last)}



Called during a query process with a service descriptor, or to indicate that the query process is done. 

The descriptor is valid as long as you don\textquotesingle{}t continue the query process (using query\+\_\+services\+\_\+next). If you need to access the service data of a service delivered by the callback after continuation, you need to write the descriptor to a global place, and also copy length bytes from offset to a global place. Alternatively, if you call query\+\_\+services\+\_\+next to end the query process (by setting next to 0), the descriptor is valid until the next query process.

In the last call to this method, is\+\_\+last is set to 1. The last call might not contain a service. An offset value of NULL indicates that this invokation of the callback does not contain a service.

Even after the is\+\_\+last call you have to invoke query\+\_\+services\+\_\+next with next set to 0, to explicitly end the query process. \mbox{\Hypertarget{sfsc__adapter_8h_a1969b502e38168910b9e57d952369316}\label{sfsc__adapter_8h_a1969b502e38168910b9e57d952369316}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!sfsc\_request\_callback@{sfsc\_request\_callback}}
\index{sfsc\_request\_callback@{sfsc\_request\_callback}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{sfsc\_request\_callback}{sfsc\_request\_callback}}
{\footnotesize\ttfamily typedef void() sfsc\+\_\+request\+\_\+callback(\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$adapter, \mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} payload, sfsc\+\_\+bool timeout, void $\ast$mapping\+\_\+arg, sfsc\+\_\+bool $\ast$b\+\_\+auto\+\_\+advance)}



Invoked when an answer to a request is receieved, or when the request times out. 

The timeout parameter is set to 1 if the callback invokation is caused by a timeout, to 0 if an answer is deleivered.

mapping\+\_\+arg is a mapping-\/argument (explained in the request functions documentation with an example).

The payload buffer is only valid during the current user task micro step (see the user\+\_\+task documentation). b\+\_\+auto\+\_\+advance is an out-\/parameter (meaning that you should set it), that lets you pause the user task on the current mirco step\+: if you set it to 0, you will enter the pause state and the payload pointer will be valid, even after the callback returns. On the other hand, the user task will not advance to the next micro step until you leave the pause state manually (see advance\+\_\+user\+\_\+ring). Usually, you want to set b\+\_\+auto\+\_\+advance to 1. If the request timed out, you should not modify b\+\_\+auto\+\_\+advance, as it will point to NULL. 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{sfsc__adapter_8h_acea1c001c6a80d2a3109aedd11232f29}\label{sfsc__adapter_8h_acea1c001c6a80d2a3109aedd11232f29}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!adapter\_stats@{adapter\_stats}}
\index{adapter\_stats@{adapter\_stats}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{adapter\_stats()}{adapter\_stats()}}
{\footnotesize\ttfamily \mbox{\hyperlink{sfsc__adapter_8h_a67512c6ef1c1f7e2e9cd669f21ec1d1b}{sfsc\+\_\+adapter\+\_\+stats}}$\ast$ adapter\+\_\+stats (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter }\end{DoxyParamCaption})}



Recommended way to access the stats of an adapter. 


\begin{DoxyParams}{Parameters}
{\em adapter} & The target adapter \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+adapter\+\_\+stats$\ast$ Pointer to that adapers stats 
\end{DoxyReturn}
\mbox{\Hypertarget{sfsc__adapter_8h_adecc1c0af790d4a51d7b196ed1c076e5}\label{sfsc__adapter_8h_adecc1c0af790d4a51d7b196ed1c076e5}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!advance\_user\_ring@{advance\_user\_ring}}
\index{advance\_user\_ring@{advance\_user\_ring}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{advance\_user\_ring()}{advance\_user\_ring()}}
{\footnotesize\ttfamily void advance\+\_\+user\+\_\+ring (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter }\end{DoxyParamCaption})}



Leaves the user task pause state. 

Some callback functions allow you to pause the user task and freeze it on the current micro step. To continue execution you have to call this function. You should only call this funtion if you entered the pause state, and never call it from the callback you entered the pause state, as this will skip messages and leave your adapter in a undefined state.


\begin{DoxyParams}{Parameters}
{\em adapter} & The adapter whichs user task is currently in the pause state and should continue execution \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{sfsc__adapter_8h_a36faef0ff0e5f45340846237e56f81d9}\label{sfsc__adapter_8h_a36faef0ff0e5f45340846237e56f81d9}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!answer\_channel\_request@{answer\_channel\_request}}
\index{answer\_channel\_request@{answer\_channel\_request}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{answer\_channel\_request()}{answer\_channel\_request()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 answer\+\_\+channel\+\_\+request (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{struct__sfsc__server}{sfsc\+\_\+server}} $\ast$}]{server,  }\item[{sfsc\+\_\+int32}]{expected\+\_\+reply\+\_\+id,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{reply\+\_\+topic,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_a487711a208cf17fd8d171031dae258f8}{sfsc\+\_\+channel\+\_\+answer}} $\ast$}]{channel\+\_\+answer,  }\item[{void $\ast$}]{mapping\+\_\+arg,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aaaee1dca7def711316b62f037165b3e0}{sfsc\+\_\+answer\+\_\+ack\+\_\+callback}} $\ast$}]{on\+\_\+ack }\end{DoxyParamCaption})}



Used to answer a channel request. 

This function must only be called by channel server services. It behaves just like answer\+\_\+request, so see there for documentation.

The only difference is that instead of passing a pointer to a binary payload, you have to pass a pointer to a sfsc\+\_\+channel\+\_\+answer. The channel\+\_\+answers use-\/time equals the use-\/time of the payload in the answer\+\_\+request function. It is also mutable, meaning that you are allowed to edit it. \mbox{\Hypertarget{sfsc__adapter_8h_a03acde575324406f3d90b1196b097f5f}\label{sfsc__adapter_8h_a03acde575324406f3d90b1196b097f5f}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!answer\_request@{answer\_request}}
\index{answer\_request@{answer\_request}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{answer\_request()}{answer\_request()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 answer\+\_\+request (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{struct__sfsc__server}{sfsc\+\_\+server}} $\ast$}]{server,  }\item[{sfsc\+\_\+int32}]{expected\+\_\+reply\+\_\+id,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{reply\+\_\+topic,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}} $\ast$}]{payload,  }\item[{void $\ast$}]{mapping\+\_\+arg,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aaaee1dca7def711316b62f037165b3e0}{sfsc\+\_\+answer\+\_\+ack\+\_\+callback}} $\ast$}]{on\+\_\+ack }\end{DoxyParamCaption})}



Answers a request. 

After sending an answer, the original requestor will (hopefully) receive it and send an acknowledge for the answer. If the acknowledge is received in time, the on\+\_\+ack callback will be invoked. If not, an attempt is automatically made to send it again. The maximal send again attempt count and the wait time are configured in the server\+\_\+struct (see there for more information). If a server does not require its answers to be acknowledged and which are thus only send once, it is called a fire-\/and-\/forget server.

The expected\+\_\+reply\+\_\+id and reply\+\_\+topic are given to you by the on\+\_\+request function of the corresponding sfsc\+\_\+server. The use-\/time of the reply\+\_\+topic is the time until the on\+\_\+ack callback is invoked. During this time, it must be valid and immutable. For fire-\/and-\/forget servers, the use-\/time of the reply\+\_\+topic is only this functions runtime, meaning that its only neccessary to be vaid and immutable until this function returns.

The payload parameter is a pointer to the actual payload you want to transmitt in the answer. The use-\/time for this is either until the on\+\_\+ack callback is invoked, or for fire-\/and-\/forget servers, this functions runtime. Since this is a pointer to a sfsc\+\_\+buffer and not a sfsc\+\_\+buffer, both, the pointer to the sfsc\+\_\+buffer and the content pointer inside that buffer must be valid during the use-\/time. The payload buffer can be mutable\+: you are allowed to change the content pointer or the content it points to. This is usefull in some situation, e.\+g.\+: Imaging answering a request with a sensor measurement, stored behind payload-\/$>$content. You do not receieve an acknowledge in time, so the answer is send again. But during this peroid, the the measurement changed. Since you were allowed to change payload-\/$>$content, you updated it, and the retransmission of the answer will contain the new measurement.

Answering a request to an non-\/fire-\/and-\/forget server will require a free acknowledge memory slot. If an attempt is made to answer a request on such a server and there are already MAX\+\_\+\+PENDING\+\_\+\+ACKS answer processes ongoing, a E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT will be returned. The acknowledge memory slot is freed once the on\+\_\+ack callback is invoked.

The mapping\+\_\+arg parameter is a mapping-\/argument (explained in the request functions documentation with an example).


\begin{DoxyParams}{Parameters}
{\em adapter} & An operational adapter \\
\hline
{\em server} & The server that is answering a request \\
\hline
{\em expected\+\_\+reply\+\_\+id} & An answer identification number obtained by the original request \\
\hline
{\em reply\+\_\+topic} & The answers reply topic, obtained by the original request \\
\hline
{\em payload} & The actual answer payload \\
\hline
{\em mapping\+\_\+arg} & Optional; Serves as mapping-\/argument \\
\hline
{\em on\+\_\+ack} & A callback to invoke once an acknowledge is received, can be NULL \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK or one of the error codes below 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT} & If there is no free acknowledge memory slot while trying to answer a non-\/fire-\/and-\/forget request \\
\hline
{\em Various} & Network Errors There are serveral other, network-\/related errors that can occure \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{sfsc__adapter_8h_a1591f2771368859f7c8980dde2c73e34}\label{sfsc__adapter_8h_a1591f2771368859f7c8980dde2c73e34}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!channel\_request@{channel\_request}}
\index{channel\_request@{channel\_request}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{channel\_request()}{channel\_request()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 channel\+\_\+request (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{topic,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{payload,  }\item[{sfsc\+\_\+uint64}]{timeout\+\_\+time,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_a8734edf2cb2e03719e603dec6c2d049f}{relative\+\_\+sfsc\+\_\+service\+\_\+descriptor}} $\ast$}]{descriptor,  }\item[{sfsc\+\_\+uint8 $\ast$}]{descriptor\+\_\+space,  }\item[{sfsc\+\_\+size}]{descriptor\+\_\+space\+\_\+lenght,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_a1497b54b1ae44a7cac6fb4f93a8217da}{sfsc\+\_\+channel\+\_\+request\+\_\+callback}} $\ast$}]{on\+\_\+answer,  }\item[{void $\ast$}]{mapping\+\_\+arg }\end{DoxyParamCaption})}



Makes a request call to a channel server service. 

This function behaves like the request function, so see there for documentation. The only difference is, what the answer is, and how it is delivered.

Instead of normal binary payload, a channel\+\_\+request will result in a publisher service description as answer, in the same format as the query\+\_\+service function would return it. The difference to the query\+\_\+service function is, that the framework can not know, how many simultaneous channel requests you want to make. Thus it can not statically allocate memory for the service descriptors. As consequence, you have to allocate this memory yourself and pass it to this method. The memory must be large enough to hold the received service. If you do not know anything about the size of the service, it might be a good idea to use REGISTRY\+\_\+\+BUFFER\+\_\+\+SIZE as orientation. What happens if the descriptor\+\_\+space\+\_\+length is insufficient is described in the sfsc\+\_\+channel\+\_\+request\+\_\+callback documentation.


\begin{DoxyParams}{Parameters}
{\em descriptor} & Pointer to a relative\+\_\+sfsc\+\_\+service\+\_\+descriptor which will be filled \\
\hline
{\em descriptor\+\_\+space} & Pointer to the start of the usable memory area \\
\hline
{\em descriptor\+\_\+space\+\_\+lenght} & Length of the usable memory area \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{sfsc__adapter_8h_a1a971fb6b660a3400b6bc6fd072586e0}\label{sfsc__adapter_8h_a1a971fb6b660a3400b6bc6fd072586e0}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!publish@{publish}}
\index{publish@{publish}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{publish()}{publish()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 publish (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{struct__sfsc__publisher}{sfsc\+\_\+publisher}} $\ast$}]{publisher,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{payload }\end{DoxyParamCaption})}



Publishes data through a publisher. 

The publisher must be registered with this adapter, either by the register\+\_\+publisher or the register\+\_\+publisher\+\_\+unregistered function.

The use-\/time of the payload is this functions runtime and must be immutable for the duration.


\begin{DoxyParams}{Parameters}
{\em adapter} & An operational adapter this publisher is registered to \\
\hline
{\em publisher} & The publisher to publish the data \\
\hline
{\em payload} & The data to publish \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK 
\end{DoxyReturn}
\mbox{\Hypertarget{sfsc__adapter_8h_a4e1311fbc5ccafdc40d075390ac1db62}\label{sfsc__adapter_8h_a4e1311fbc5ccafdc40d075390ac1db62}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!query\_services@{query\_services}}
\index{query\_services@{query\_services}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{query\_services()}{query\_services()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 query\+\_\+services (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_a45d55712718b8b83acf89e41f66134c2}{sfsc\+\_\+query\+\_\+callback}} $\ast$}]{on\+\_\+service }\end{DoxyParamCaption})}



Starts a query process to obtain registered services from the core. 

Only one query process might be running simultaniously. During a query process, all valid services will be delivered through the callback. The query process queries the cores event log in reversed order, so that more recently registered services will be found first.

After a service is found and delivered to the calling application throught the callback, the query process is paused, until it is explicitly continued by a call to the query\+\_\+services\+\_\+next function. See the documentation of the sfsc\+\_\+query\+\_\+callback for more information on the delivered service data.


\begin{DoxyParams}{Parameters}
{\em adapter} & An operational adapter throught which the core is queried \\
\hline
{\em on\+\_\+service} & The callback all receieved services are delivered to \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK if starting the query process was successfull, or one of the error codes below 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em E\+\_\+\+QUERY\+\_\+\+IN\+\_\+\+PROGRESS} & If there is already an other query process \\
\hline
{\em Various} & Network Errors There are serveral other, network-\/related errors that can occure \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{sfsc__adapter_8h_abe50351d6b8d32fc7e8b52a63163cc6b}\label{sfsc__adapter_8h_abe50351d6b8d32fc7e8b52a63163cc6b}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!query\_services\_next@{query\_services\_next}}
\index{query\_services\_next@{query\_services\_next}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{query\_services\_next()}{query\_services\_next()}}
{\footnotesize\ttfamily void query\+\_\+services\+\_\+next (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{sfsc\+\_\+bool}]{next }\end{DoxyParamCaption})}



Tells the framework to continue or to end a currently ongoing query process. 

Once a service is found during the query process, the associated callback is invoked and the query process enters a pause state. It is then either continued by a call to this function with next set to 1 or ended with next set to 0.

It is not neccesary, but allowed, that this function is invoked from a query callback. It is also allowed for it to be invoked from any other part of the programm, as long as it is invoked eventually.

Calling this function while there is no query process ongoing (checkable by the adapter\+\_\+stats function) will result in undefined behaviour.


\begin{DoxyParams}{Parameters}
{\em adapter} & The adapter which is currently in a query process \\
\hline
{\em next} & 1 to continue the query process, 0 to end it \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{sfsc__adapter_8h_adb7e6ee6ba9c8bf9a8bd3f6874887019}\label{sfsc__adapter_8h_adb7e6ee6ba9c8bf9a8bd3f6874887019}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!random\_uuid@{random\_uuid}}
\index{random\_uuid@{random\_uuid}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{random\_uuid()}{random\_uuid()}}
{\footnotesize\ttfamily void random\+\_\+uuid (\begin{DoxyParamCaption}\item[{sfsc\+\_\+uint8}]{target\mbox{[}\+UUID\+\_\+\+LEN\mbox{]} }\end{DoxyParamCaption})}



Generates and writes a random 128bit UUID in standard-\/hexgroup-\/format to the target buffer. 

Since the generated UUID is random, it can be classified as type 4 UUID.

This method generates 2 random sfsc\+\_\+uint64 and formats them in standard-\/hexgroup-\/format. Standard-\/hexgroup-\/format consists of 5 datagroups, each group represended by ASCII letters a-\/f and numbers 0-\/9. The groups are separated by the -\/ ASCII symbol.

Examples\+: 23236572-\/6963-\/6973-\/7473-\/757065722323, 550e8400-\/e29b-\/11d4-\/a716-\/446655440000


\begin{DoxyParams}{Parameters}
{\em target} & A at least UUID\+\_\+\+LEN bytes long buffer to write the formated UUID to \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{sfsc__adapter_8h_a36e54333c8c4c5cfe295c474953ea0b9}\label{sfsc__adapter_8h_a36e54333c8c4c5cfe295c474953ea0b9}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!register\_publisher@{register\_publisher}}
\index{register\_publisher@{register\_publisher}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{register\_publisher()}{register\_publisher()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 register\+\_\+publisher (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{struct__sfsc__publisher}{sfsc\+\_\+publisher}} $\ast$}]{publisher,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{name,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{custom\+\_\+tags,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{output\+\_\+message\+\_\+type,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_a9606cb226543c2d13c6d81f6de079326}{sfsc\+\_\+command\+\_\+callback}} $\ast$}]{command\+\_\+callback }\end{DoxyParamCaption})}



Sets up a publisher service and registers it with the core. 

If you want to set up the services id and topic manually, see the sfsc\+\_\+publisher struct documentation for instructions.

After successfull registration, this function will set the unregistered field of the publisher to 0.

All sfsc\+\_\+buffer parameters for this method must be immutable and mut be valid until this function returns (their use-\/time equals this functions run time). For more information about mutability, see the sfsc\+\_\+buffer struct documentation. To omit an optional sfsc\+\_\+buffer parameter use sfsc\+\_\+buffer\+\_\+default as value.

Registering a publisher saves a pointer to that publisher in the adapter state, so you must not copy the publisher struct around as long as it is registered with the adapter! Also, registering will fail if there is no free publisher memory slot to store the pointer to that publisher in the adapter. In this case E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT will be returned. The maximal number of at the same time registered publisher per adapter can be configured using MAX\+\_\+\+PUBLISHERS.

Also, since the publisher will be registered in the service registry, this call requires a free command memory slot and will also return E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT if their are currently already MAX\+\_\+\+SIMULTANIOUS\+\_\+\+COMMANDS ongoing. The command memory slot will be occupied until the callback is invoked.


\begin{DoxyParams}{Parameters}
{\em adapter} & An operational adapter \\
\hline
{\em publisher} & The publisher to register with this adapter, see the sfsc\+\_\+publisher struct for more information \\
\hline
{\em name} & The name of this publisher \\
\hline
{\em custom\+\_\+tags} & Optional; custom tags for the publisher \\
\hline
{\em output\+\_\+message\+\_\+type} & Optional; can be used to annotate the format of the published messages \\
\hline
{\em command\+\_\+callback} & Optional; a callback that is invoked after service registration with the core was successful \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK or one of the error codes below 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em SFSC\+\_\+\+OK} & This indicates that registering the publisher into the adapter was successfull, and that the appropriate command to register the publisher into the cores service registry was issued. \\
\hline
{\em E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT} & There are already MAX\+\_\+\+PUBLISHERS registered with this adapter, so there is no memory slot left for this one OR if there are currently already MAX\+\_\+\+SIMULTANIOUS\+\_\+\+COMMANDS ongoing \\
\hline
{\em Various} & Network Errors There are serveral other, network-\/related errors that can occure \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{sfsc__adapter_8h_a9f3a86f49777fbd148d95c724c568bdb}\label{sfsc__adapter_8h_a9f3a86f49777fbd148d95c724c568bdb}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!register\_publisher\_unregistered@{register\_publisher\_unregistered}}
\index{register\_publisher\_unregistered@{register\_publisher\_unregistered}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{register\_publisher\_unregistered()}{register\_publisher\_unregistered()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 register\+\_\+publisher\+\_\+unregistered (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{struct__sfsc__publisher}{sfsc\+\_\+publisher}} $\ast$}]{publisher }\end{DoxyParamCaption})}



Sets up a publisher you can publish with, but does not register it in the cores service registry. 

This function behaves mostly like register\+\_\+publisher, but since this publisher is not registered into the service registry, it does not have a name, custom\+\_\+tags or an ouput\+\_\+message\+\_\+type.

It will still have an service id and a topic, which are either setup manually or automaticly generated, according to the rules specified in the sfsc\+\_\+publisher documentation. Also, for registering the publisher with the adapter, the adapter needs to have a free publisher memory slot (again, see register\+\_\+publisher).

This function will set the unregistred field of the publisher to 1.

A subscriber can subscribe to an unregistred publisher, if it knows the unregistered publishers topic. In most cases, this will happen in the context of a channel request.

Even if the publisher is not registered into the service registry, it sill needs to be properly unregistered form the adapter after usage by the unregister\+\_\+publisher function!


\begin{DoxyParams}{Parameters}
{\em adapter} & An operational adapter \\
\hline
{\em publisher} & The publisher to register with this adapter, see the sfsc\+\_\+publisher struct for more information \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK or one of the error codes below 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em SFSC\+\_\+\+OK} & This indicates that registering the publisher into the adapter was successfull, and that the appropriate command to register the publisher into the cores service registry was issued. \\
\hline
{\em E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT} & There are already MAX\+\_\+\+PUBLISHERS registered with this adapter, so there is no memory slot left for this one \\
\hline
{\em Various} & Network Errors There are serveral other, network-\/related errors that can occure \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{sfsc__adapter_8h_ab548429c2d440ec47260c2cc69a288cd}\label{sfsc__adapter_8h_ab548429c2d440ec47260c2cc69a288cd}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!register\_server@{register\_server}}
\index{register\_server@{register\_server}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{register\_server()}{register\_server()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 register\+\_\+server (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{struct__sfsc__server}{sfsc\+\_\+server}} $\ast$}]{server,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{name,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{custom\+\_\+tags,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{output\+\_\+message\+\_\+type,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{input\+\_\+message\+\_\+type,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_a9606cb226543c2d13c6d81f6de079326}{sfsc\+\_\+command\+\_\+callback}} $\ast$}]{command\+\_\+callback }\end{DoxyParamCaption})}



Sets up a server service and registers it with the core. 

If you want to set up the services id and topic manually, see the sfsc\+\_\+server struct documentation for instructions.

Also, the function that is invoked when recieving requests, the servers acknowledge strategy and if this is a channel service must be configured in the sfsc\+\_\+server before calling this function, so see their for instructions.

All sfsc\+\_\+buffer parameters for this method must be immutable and must be valid until this function returns (their use-\/time equals this functions run time). For more information about mutability, see the sfsc\+\_\+buffer struct documentation. To omit an optional sfsc\+\_\+buffer parameter use sfsc\+\_\+buffer\+\_\+default as value.

Registering a server saves a pointer to that server in the adapter state, so you must not copy the server struct around as long as it is registered with the adapter! Also, registering will fail if there is no free server memory slot to store the pointer to that server in the adapter. In this case E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT will be returned. The maximal number of at the same time registered server per adapter can be configured using MAX\+\_\+\+SERVERS.

Also, since the server will be registered in the service registry, this call requires a free command memory slot and will also return E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT if their are currently already MAX\+\_\+\+SIMULTANIOUS\+\_\+\+COMMANDS ongoing. The command memory slot will be occupied until the callback is invoked.


\begin{DoxyParams}{Parameters}
{\em adapter} & An operational adapter \\
\hline
{\em server} & The server to register with this adapter, see the sfsc\+\_\+server struct for more information \\
\hline
{\em name} & The name of this server \\
\hline
{\em custom\+\_\+tags} & Optional; custom tags for the server \\
\hline
{\em output\+\_\+message\+\_\+type} & Optional; can be used to annotate the format of the messages the server sends as answers \\
\hline
{\em input\+\_\+message\+\_\+type} & Optional; can be used to annotate the format of the messages the server accepts on requests \\
\hline
{\em command\+\_\+callback} & Optional; a callback that is invoked after service registration with the core was successful \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK or one of the error codes below 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em SFSC\+\_\+\+OK} & This indicates that registering the server into the adapter was successfull, and that the appropriate command to register the into into the cores service registry was issued. \\
\hline
{\em E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT} & There are already MAX\+\_\+\+SERVERS registered with this adapter, so there is no memory slot left for this one OR if there are currently already MAX\+\_\+\+SIMULTANIOUS\+\_\+\+COMMANDS ongoing \\
\hline
{\em Various} & Network Errors There are serveral other, network-\/related errors that can occure \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{sfsc__adapter_8h_a907e055e091da55aee6ea185f042bd30}\label{sfsc__adapter_8h_a907e055e091da55aee6ea185f042bd30}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!register\_subscriber@{register\_subscriber}}
\index{register\_subscriber@{register\_subscriber}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{register\_subscriber()}{register\_subscriber()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 register\+\_\+subscriber (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{struct__sfsc__subscriber}{sfsc\+\_\+subscriber}} $\ast$}]{subscriber }\end{DoxyParamCaption})}



Subscribes to a sfsc publisher through the given adapter. 

The publishers topic which should be subscribed to and the callback function which should be invoked can be set in the corresponding sfsc\+\_\+subscriber struct. For mutability rules of topic and callback function (if they are allowed to change), see the sfsc\+\_\+subscriber structs documentation.

Registering a subscriber saves a pointer to that subscriber in the adapter state, so you must not copy the subscriber struct around as long as it is registered with the adapter! Also, registering will fail if there is no free subscriber memory slot to store the pointer to that subscriber in the adapter. In this case E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT will be returned. The maximal number of at the same time registered subscribers per adapter can be configured using MAX\+\_\+\+SUBSCRIBERS.

Calling this function with an non-\/operational adapter will result in unpredictable behaviour! Registering the same subscriber multiple times will also result in unpredictable behaviour!


\begin{DoxyParams}{Parameters}
{\em adapter} & An operational adapter which will be used for the subscription \\
\hline
{\em subscriber} & Pointer to the subscriber struct holding the topic and callback information \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK on success or one of the error codes below 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT} & There are already MAX\+\_\+\+SUBSCRIBERS registered with this adapter, so there is no memory slot left for this one \\
\hline
{\em Various} & Network Errors There are serveral other, network-\/related errors that can occure \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{sfsc__adapter_8h_ac826d18cb2e8ffff9d1651cfe4a95df3}\label{sfsc__adapter_8h_ac826d18cb2e8ffff9d1651cfe4a95df3}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!release\_session@{release\_session}}
\index{release\_session@{release\_session}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{release\_session()}{release\_session()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 release\+\_\+session (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter }\end{DoxyParamCaption})}



Releases the sockets associated with an adapter. 

This function releases the sockets associated with an adapter, by calling the socket\+\_\+release function with every used socket. This is not equivalent to gracefully stopping a sfsc sesseion (since there is no such thing as gracefully stopping a sfscs session, see \textquotesingle{}Stop using the API\textquotesingle{} in the readme).

If you want to reuse the adapter struct after releasing the adapter, make sure to reset it to sfsc\+\_\+adapter\+\_\+\+DEFAULT\+\_\+\+INIT.


\begin{DoxyParams}{Parameters}
{\em adapter} & The adapter to release \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
SFSC\+\_\+\+OK on success or an error code (determined by sfsc\+\_\+sockets.\+h) 
\end{DoxyReturn}
\mbox{\Hypertarget{sfsc__adapter_8h_ac1ed1601a750a283cabb2993cb61c29d}\label{sfsc__adapter_8h_ac1ed1601a750a283cabb2993cb61c29d}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!request@{request}}
\index{request@{request}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{request()}{request()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 request (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{topic,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_aa436417a69f99cdee2a8eead1ee15adb}{sfsc\+\_\+buffer}}}]{payload,  }\item[{sfsc\+\_\+uint64}]{timeout\+\_\+time,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_a1969b502e38168910b9e57d952369316}{sfsc\+\_\+request\+\_\+callback}} $\ast$}]{on\+\_\+answer,  }\item[{void $\ast$}]{mapping\+\_\+arg }\end{DoxyParamCaption})}



Makes a request call to a server service. 

The topic of the server service is usually obtained by a registry query. The use-\/time of the topic and the payload equal the functions runtime ( until this function returns) and must both be immutable for this time (see the sfsc\+\_\+buffer documentation for more information about mutability).

If an answer to the request is received, the callback is invoked. For information on how the data will be delivered, see the callbacks documentation.

You can specify a timeout\+\_\+time in ms. If this time passes without receiving an answer to this request, the callback is invoked with timeout set to 1.

Each request you want to make needs a request memory slot in the given adapter for the time of the request (until the callback is invoked). If there is no free request memory slot, E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT will be returned. You can configure the amount of available request memory slots using MAX\+\_\+\+SIMULTANIOUS\+\_\+\+REQUESTS.

As the use-\/time of the request topic and payload is only the functions runtime, they are both not necessarily valid when an answer is recieved, and thus can not be passed to the callback. But most certainly you want to know to which request the recieved answer belongs. One way is to declare a separate callback function for each of your requests. An other way to let you know which request function call the callbacks invokation belongs to, is to use the optional mapping\+\_\+arg parameter as a so called mapping-\/argument. If and what you store behind the mapping\+\_\+arg pointer is opaque to the framework. The callback function will be invoked with this mapping\+\_\+arg. You can then, based on the mapping\+\_\+arg, reason, what request call the answer belongs to. For example, if you know that even if the use-\/time of the request topic buffer is over it will continue to be valid, you can pass this as mapping\+\_\+arg. Or you define that you will use the mapping\+\_\+arg pointer as numerical value and treat it as an normal integer number instead of a pointer. Then you can assign unique request ids to your topics.


\begin{DoxyParams}{Parameters}
{\em adapter} & The operational adapter to make the request with \\
\hline
{\em topic} & The server services topic to make the request to \\
\hline
{\em payload} & The payload of the request \\
\hline
{\em timeout\+\_\+time} & The timeout time in ms, 0 for no timeout restrictions \\
\hline
{\em on\+\_\+answer} & The callback that is invoked when receiving an answer or on timeout \\
\hline
{\em mapping\+\_\+arg} & Optional; Serves as mapping-\/argument (see the text above for explanation) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK or one of the error codes below 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em SFSC\+\_\+\+OK} & This indicates that registering the publisher into the adapter was successfull, and that the appropriate command to register the publisher into the cores service registry was issued. \\
\hline
{\em E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT} & There currently already MAX\+\_\+\+SIMULTANIOUS\+\_\+\+REQUESTS MAX\+\_\+\+PUBLISHERS ongoing \\
\hline
{\em Various} & Network Errors There are serveral other, network-\/related errors that can occure \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{sfsc__adapter_8h_a478abd5351cea939fd22e21ba976f97a}\label{sfsc__adapter_8h_a478abd5351cea939fd22e21ba976f97a}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!start\_session@{start\_session}}
\index{start\_session@{start\_session}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{start\_session()}{start\_session()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 start\+\_\+session (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{const char $\ast$}]{address,  }\item[{int}]{original\+\_\+control\+\_\+pub\+\_\+port,  }\item[{int}]{original\+\_\+control\+\_\+sub\+\_\+port,  }\item[{int}]{original\+\_\+data\+\_\+pub\+\_\+port,  }\item[{int}]{original\+\_\+data\+\_\+sub\+\_\+port }\end{DoxyParamCaption})}



Stats a sfsc adapter session without bootstraping. 

See start\+\_\+session\+\_\+bootstraped for details. \mbox{\Hypertarget{sfsc__adapter_8h_ab6bd4332c56b21f6b9ce25c80eadbde4}\label{sfsc__adapter_8h_ab6bd4332c56b21f6b9ce25c80eadbde4}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!start\_session\_bootstraped@{start\_session\_bootstraped}}
\index{start\_session\_bootstraped@{start\_session\_bootstraped}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{start\_session\_bootstraped()}{start\_session\_bootstraped()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 start\+\_\+session\+\_\+bootstraped (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{const char $\ast$}]{address,  }\item[{int}]{original\+\_\+control\+\_\+pub\+\_\+port }\end{DoxyParamCaption})}



Starts a sfsc adapter session with bootstraping. 

The adapter is not operational after this function returns. It first needs to do a handshake and connect to the other sfsc sockets of the core. You should start system-\/tasking (see the system\+\_\+task function) with this adapter and check the state field of the stats object (accessible with the adapter\+\_\+stats function) after each step. It will eventually become SFSC\+\_\+\+STATE\+\_\+\+OPERATIONAL, making the adapter operational.


\begin{DoxyParams}{Parameters}
{\em adapter} & Pointer to the adapter struct, all state information will be saved there \\
\hline
{\em address} & The address of the core, it will be passed to your socket implementation \\
\hline
{\em original\+\_\+control\+\_\+pub\+\_\+port} & The port of the cores control pub socket \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK or an error code 
\end{DoxyReturn}
\mbox{\Hypertarget{sfsc__adapter_8h_ada689902e1addaeb4a999c775c6705d0}\label{sfsc__adapter_8h_ada689902e1addaeb4a999c775c6705d0}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!system\_task@{system\_task}}
\index{system\_task@{system\_task}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{system\_task()}{system\_task()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 system\+\_\+task (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter }\end{DoxyParamCaption})}



Executes a single system task step on the adapter. 

This function is non-\/blocking, and must be called cyclicly, with a high enough frequency on an adapter, on which the start\+\_\+session or start\+\_\+session\+\_\+bootstraped function was called. To read more about the execution model, see the readme.

This function returns an error code, which is SFSC\+\_\+\+OK on success. An other return code indicates an error, a list or error codes can be found in sfsc\+\_\+errors.\+h and zmtp\+\_\+states.\+h. Some errors are recoverable, again, see the readme.


\begin{DoxyParams}{Parameters}
{\em adapter} & An adapter \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK or an error code 
\end{DoxyReturn}
\mbox{\Hypertarget{sfsc__adapter_8h_ac62616aff23fe7cac25ed256ce4e200e}\label{sfsc__adapter_8h_ac62616aff23fe7cac25ed256ce4e200e}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!unregister\_publisher@{unregister\_publisher}}
\index{unregister\_publisher@{unregister\_publisher}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{unregister\_publisher()}{unregister\_publisher()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 unregister\+\_\+publisher (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{struct__sfsc__publisher}{sfsc\+\_\+publisher}} $\ast$}]{publisher,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_a9606cb226543c2d13c6d81f6de079326}{sfsc\+\_\+command\+\_\+callback}} $\ast$}]{command\+\_\+callback }\end{DoxyParamCaption})}



Unregisters a publisher. 

Unregistering frees the publishers publisher memory slot in the adapter.

If this publisher is registered with the service registry, it will be removed from it. Removing requires a free command memory slot and will return E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT if there are currently already MAX\+\_\+\+SIMULTANIOUS\+\_\+\+COMMANDS ongoing. The command memory slot will be occupied until the callback is invoked.

Even if the publisher is not registered with the service registry (because it was created with register\+\_\+publisher\+\_\+unregistered), this function must still be called!

The callback is invoked after the publisher was removed from the service registry, with created set to 0. Since with unregistered publishers this is never the case, the callback is ignored and should be set to NULL.


\begin{DoxyParams}{Parameters}
{\em adapter} & An operational adapter \\
\hline
{\em publisher} & The publisher to shut down \\
\hline
{\em command\+\_\+callback} & For registered publishers only; Invoked after the publisher was removed from the service registry \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK or one of the error codes below 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em SFSC\+\_\+\+OK} & This indicates that unregistering the publisher from the adapter was successfull, and if this publisher is registered in the service registry, that the appropriate command to unregister the publisher from there was issued \\
\hline
{\em E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT} & There are currently already MAX\+\_\+\+SIMULTANIOUS\+\_\+\+COMMANDS ongoing \\
\hline
{\em Various} & Network Errors There are serveral other, network-\/related errors that can occure \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{sfsc__adapter_8h_aa064ef0413ec5d1e8e391ad81dcf9ef6}\label{sfsc__adapter_8h_aa064ef0413ec5d1e8e391ad81dcf9ef6}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!unregister\_server@{unregister\_server}}
\index{unregister\_server@{unregister\_server}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{unregister\_server()}{unregister\_server()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 unregister\+\_\+server (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{struct__sfsc__server}{sfsc\+\_\+server}} $\ast$}]{server,  }\item[{\mbox{\hyperlink{sfsc__adapter_8h_a9606cb226543c2d13c6d81f6de079326}{sfsc\+\_\+command\+\_\+callback}} $\ast$}]{command\+\_\+callback }\end{DoxyParamCaption})}



Unregisters a server. 

Unregistering frees the servers server memory slot in the adapter.

The server will be removed from the service registry. Removing requires a free command memory slot and will return E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT if there are currently already MAX\+\_\+\+SIMULTANIOUS\+\_\+\+COMMANDS ongoing. The command memory slot will be occupied until the callback is invoked. The callback is invoked after the server was removed from the service registry, with created set to 0.


\begin{DoxyParams}{Parameters}
{\em adapter} & An operational adapter \\
\hline
{\em server} & The server to shut down \\
\hline
{\em command\+\_\+callback} & Invoked after the server was removed from the service registry \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK or one of the error codes below 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em SFSC\+\_\+\+OK} & Indicates that unregistering the server from the adapter was successfull and that the appropriate command to unregister the server from the service registry was issued \\
\hline
{\em E\+\_\+\+NO\+\_\+\+FREE\+\_\+\+SLOT} & There are currently already MAX\+\_\+\+SIMULTANIOUS\+\_\+\+COMMANDS ongoing \\
\hline
{\em Various} & Network Errors There are serveral other, network-\/related errors that can occure \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{sfsc__adapter_8h_addaf3873c9e805b7a3b5ab72c5f59976}\label{sfsc__adapter_8h_addaf3873c9e805b7a3b5ab72c5f59976}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!unregister\_subscriber@{unregister\_subscriber}}
\index{unregister\_subscriber@{unregister\_subscriber}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{unregister\_subscriber()}{unregister\_subscriber()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 unregister\+\_\+subscriber (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter,  }\item[{\mbox{\hyperlink{struct__sfsc__subscriber}{sfsc\+\_\+subscriber}} $\ast$}]{subscriber }\end{DoxyParamCaption})}



Unregisters a subscriber and unsubscribe messages on that topic. 

If the given subscriber is registered with this adapter to receieve published messages, it will be unregistered and a subscriber memory slot in the adapter will be freed. After this function returns, the callback of the subscriber will not be invoked again.

Unregistering a not registered subscriber will result in a success.


\begin{DoxyParams}{Parameters}
{\em adapter} & The operational adapter, from which to unregister the subscriber \\
\hline
{\em subscriber} & The subscriber to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK on success or one of the Various Network Errors 
\end{DoxyReturn}
\mbox{\Hypertarget{sfsc__adapter_8h_a87bb0e1bf28ae6c6b432f2e3e1e998e3}\label{sfsc__adapter_8h_a87bb0e1bf28ae6c6b432f2e3e1e998e3}} 
\index{sfsc\_adapter.h@{sfsc\_adapter.h}!user\_task@{user\_task}}
\index{user\_task@{user\_task}!sfsc\_adapter.h@{sfsc\_adapter.h}}
\doxysubsubsection{\texorpdfstring{user\_task()}{user\_task()}}
{\footnotesize\ttfamily sfsc\+\_\+int8 user\+\_\+task (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sfsc__adapter_8h_ac6d9c7d2592acf83d5140e80d6c2d7b9}{sfsc\+\_\+adapter}} $\ast$}]{adapter }\end{DoxyParamCaption})}



Executes a single system task step on the adapter. 

The adapter must be in an operational state, or this call will lead to undefined behaviour.

If this function is called, it will execute callbacks you registered. Whether using blocking or long taking code in your callbacks is allowed or not, depends on your execution modell (see the corresponding section in the readme).

It is important to continue calling this function, even if you entered the user task pause state (mentioned in the documentation of most callback functions).

This function returns an error code, which is SFSC\+\_\+\+OK on success. An other return code indicates an error, a list or error codes can be found in sfsc\+\_\+errors.\+h and zmtp\+\_\+states.\+h. Some errors are recoverable, again, see the readme.


\begin{DoxyParams}{Parameters}
{\em adapter} & An operational adapter \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sfsc\+\_\+int8 SFSC\+\_\+\+OK or an error code 
\end{DoxyReturn}
