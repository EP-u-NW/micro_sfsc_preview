\label{index_md_Readme}%
\Hypertarget{index_md_Readme}%
The \href{https://github.com/nalim2/SFSC}{\texttt{ Shop-\/\+Floor Service Connector (SFSC)}} is an easy-\/to-\/use, service-\/orientated communication framework for \href{https://en.wikipedia.org/wiki/Fourth_Industrial_Revolution}{\texttt{ Industry 4.\+0}}, developed at the \href{https://www.isw.uni-stuttgart.de/forschung/kommunikation/SFSC/}{\texttt{ University of Stuttgart}}. Mirco\+SFSC is a microcontroller ready implementation of the SFSC adapter role. This documentation provides a quick overview about the usage and the features of the Micro\+SFSC framework, where as an in deep analysis can be found in this \href{https://epnw.github.io/micro_sfsc_preview/Eric_Prokop_-_MicroSFSC.pdf}{\texttt{ white-\/paper}}(German).

This implementation is written in C and \href{https://gcc.gnu.org/onlinedocs/gcc/Standards.html}{\texttt{ conforms the C99 freestanding standard}}. If your compiler only supports ANSI-\/C, some platform depended adjustments are required.

The RAM and ROM footprint is configuration depended; in default configuration 25kB ROM and about 7-\/11kB RAM are needed. A configuration for your specific use-\/case will most likely result in lower resource requirements.

This framework does not use dynamic memory allocation.\hypertarget{index_autotoc_md1}{}\doxysection{Repository structure}\label{index_autotoc_md1}
This repository is structured the following way\+:
\begin{DoxyItemize}
\item The {\bfseries{sfsc}} folder contains the actual source code you should copy into your project.
\item The {\bfseries{platforms}} folder contains implementations for the platform dependencies for some platforms. Platform dependencies are explained in the next section.
\item The {\bfseries{docs}} folder contains a doxygen html documentation of the public header. It can be access via \href{https://epnw.github.io/micro_sfsc_preview/}{\texttt{ github pages}}. Also, the {\bfseries{docs}} folder contains latex code and the complete documentation as \href{https://epnw.github.io/micro_sfsc_preview/latex/refman.pdf}{\texttt{ PDF}}.
\item The {\bfseries{examples/scenarios}} folder contains the actual examples. Every example comes with its own preprocessor directive that must be defined to enable that example. Only one of the examples should be active at the same time. Where to define the directives is up to the used build system. The other subfolders of the {\bfseries{examples}} folder contain the initialization logic and example build instructions to the get the examples running on the corresponding platform.
\end{DoxyItemize}\hypertarget{index_autotoc_md2}{}\doxysection{Porting to your platform}\label{index_autotoc_md2}
The {\bfseries{sfsc/platform}} folder contains headers you have edit or implement for your platform if you want to use this framework. There are some existing platform ports in the {\bfseries{platforms}} folder in the root of this repository. For example, there are implementations for POSIX (including Windows with Min\+GW) systems and the ESP32 microcontroller family. This framework does not contain an IP stack, so you need to provide one (most network ready platforms will already include one). Below are some more information on the headers you need to look at.\hypertarget{index_autotoc_md3}{}\doxysubsection{sfsc\+\_\+types.\+h}\label{index_autotoc_md3}
{\ttfamily sfsc\+\_\+types.\+h} contains declarations of different datatypes. If your platform provides {\ttfamily stdint.\+h} and {\ttfamily stdbool.\+h} (like all conforming freestanding C99 environments should), there is no need to edit this file. The other needed header files are from the ANSI-\/C (C90) standard.\hypertarget{index_autotoc_md4}{}\doxysubsection{sfsc\+\_\+strings.\+h}\label{index_autotoc_md4}
This framework needs some functions from the {\ttfamily strings.\+h} header (namely {\ttfamily memcpy}, {\ttfamily memset} and {\ttfamily strlen}), which is not part of any freestanding C standard. Many platforms will provide it anyway, and if you platform does, make sure to define {\itshape HAS\+\_\+\+STRING\+\_\+H} in {\ttfamily sfsc\+\_\+adapter\+\_\+cofig.\+h} (more about configuration can be read below). If this define is missing, the framework will fall back to self-\/provided, but not as efficient implementations of these functions.\hypertarget{index_autotoc_md5}{}\doxysubsection{sfsc\+\_\+platform.\+h}\label{index_autotoc_md5}
This header provides four functions you need to implement. They should behave as their function documentation demands, some important additional details are given here\+:
\begin{DoxyItemize}
\item {\ttfamily time\+\_\+ms} is used for timing and must return some means of the current time, in millisecond resolution. It is not necessary (but allowed) to provide the absolute unix time, a relative value to indicate time since the system start (or even first call of the time\+\_\+ms function) is sufficient.
\item {\ttfamily random\+\_\+bytes} needs to generate the requested amount of random bytes and write them to the specified buffer. These bytes are not used for cryptographically functions, so it\textquotesingle{}s ok for them to be pseudo-\/random. On the other hand, it is very important that the generated byte sequences are different on each system start! If your platform does not provide such a mechanism you have to do this yourself\+: You can use a pseudo-\/random generator algorithms seeded with some random sensor noise (read more on the \href{https://en.wikipedia.org/wiki/Hardware_random_number_generator\#Software_whitening}{\texttt{ von Neumann whitening algorithm}}) or the absolute unix time (if you can access it). An other approach is to store the last generated bytes in persistent memory (EEPROM), and seed your pseudo-\/random algorithm with them on system start. If you use this framework on multiple microcontrollers simultaneously, the generated random sequences must not be the same, too!
\item The {\ttfamily lock} and {\ttfamily unlock} functions are only needed for multi-\/threading, if you don\textquotesingle{}t use multi-\/threading you can provide empty implementations of these functions. If you use multi-\/threading you have to ensure that only one thread is accessing a socket for writing at the same time. This should be no problem, since the most kernels and operating systems (which most likely provide the multi-\/threading in the first place) provide synchronization mechanisms. The framework will call you with an address to an uint\+\_\+8. The address identifies the socket that should be locked/unlocked for access through other threads (you can treat the address like a numerical handle). The uint\+\_\+8t is a single byte you can freely use as memory if needed (e.\+g. to store locking information).
\end{DoxyItemize}\hypertarget{index_autotoc_md6}{}\doxysubsection{sfsc\+\_\+sockets.\+h}\label{index_autotoc_md6}
SFSC adapters communicate with SFSC cores using TCP/\+IP, and you need a to provide functions to establish this connection. The framework does not contain a own network-\/stack, since if your platform is IP-\/ready, it will most likely feature a platform optimized implementation. The API demanded by this framework is based on the POSIX Socket API (also known as BSD Socket), with the extension that most functions need to operate in a non-\/blocking way. Examples for providing this functions can be found in the {\bfseries{platforms}} folder.\hypertarget{index_autotoc_md7}{}\doxysubsection{Protobuf}\label{index_autotoc_md7}
This framework uses Nano\+PB v0.\+4.\+2 for protobuf serialization/deserialization. It is configured to not use dynamic memory allocation, and is pointed towards {\ttfamily sfsc\+\_\+strings.\+h} instead of the normal {\ttfamily strings.\+h}. Nano\+PB also depends on {\ttfamily stdbool.\+h}, {\ttfamily stdint.\+h}, {\ttfamily stddef.\+h}, and {\ttfamily limits.\+h} in its {\ttfamily pb.\+h}. If your compiler does not conform the freestanding C99 standard, you might need to edit the {\ttfamily pb.\+h} header. For more information on Nano\+PB see \href{https://jpa.kapsi.fi/nanopb/docs/index.html}{\texttt{ it\textquotesingle{}s official page}}.\hypertarget{index_autotoc_md8}{}\doxysection{The Execution model}\label{index_autotoc_md8}
The framework needs some background tasks to be handled. But it does not include any concept of threading (since your platform might already have a concept, or is not powerful enough to have such a concept). Instead, it is your responsibility to call the background tasks in a cyclic manor. There are two main tasks you need to call\+: The system task and the user task. Both tasks are designed to be non-\/blocking, but for the user task, there are some restrictions. \hypertarget{index_autotoc_md9}{}\doxysubsection{System Task}\label{index_autotoc_md9}
The system task handles connection setup and heartbeating. It will also read the network using your {\ttfamily sfsc\+\_\+socket.\+h} implementation. It is important that the system task is called with a high enough frequency, or it will fail to send heartbeats to the core in time. If this happens, the core will treat the corresponding adapter as disconnected. As a guideline, try to call the system task at least once every 5ms. The system tasks runtime is designed to be constant, which is achieved by only using non-\/blocking operations. As a consequence, the system task does not invoke your callbacks, as the framework can not know, what you are doing in your callbacks. So, instead of executing callbacks based on the data the system task receives from the network, it writes the data to an intermediate ring buffer, called the user ring. \hypertarget{index_autotoc_md10}{}\doxysubsection{User Task}\label{index_autotoc_md10}
Among other things, the user task will then go ahead and read data from the user ring, and based on them, invoke callbacks you defined during an API call. Since the user task directly executes your callbacks, what you do in them will influence the runtime of the user task. Reading one entry of data from the user ring and invoking a callback is called a micro step. How many micro steps should be taken in a single call to the user task function can be configured (using REPLAYS\+\_\+\+PER\+\_\+\+TASK). The data supplied as parameters to your callbacks are only valid during the current micro step, meaning that after your callback returns, the data will be removed from the user ring and you should no longer try to access them. If you need the data from the callback outside the callback, you have two options\+:
\begin{DoxyEnumerate}
\item Simply copy the data somewhere else. This is the easiest and safest way, but requires additional memory.
\item If you can not afford to copy the data, you can enter the {\itshape user task pause state}. In the user task pause state, the user task won\textquotesingle{}t advance to the next micro step after your callback returns. You will need to leave the pause state explicitly by calling a function. Keep in mind, that as long as you are in the pause state, no further callbacks will be invoked (exceptions are TODO). Note that even while you are currently in the pause state, you still must ensure that the system and user task functions are called (since as noted above, the user tasks needs to do other things then taking micro steps, too)! 
\end{DoxyEnumerate}\hypertarget{index_autotoc_md11}{}\doxysubsection{Blocking the User Task}\label{index_autotoc_md11}
An other important question is\+: Am I allowed to perform a blocking or long taking operation in a callback? As stated above, system and user task are designed to be non-\/blocking. Consider the following code snippet\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{// Note that this code is not runnable since it ignores multiple return values of functions that indicate the operability of the adapter}
\DoxyCodeLine{sfsc\_adapter adapter;}
\DoxyCodeLine{start\_session\_bootstraped(\&adapter,host,PORT);}
\DoxyCodeLine{while(1)\{ //global execution loop}
\DoxyCodeLine{    system\_task(\&adapter);}
\DoxyCodeLine{    user\_task(\&adapter);}
\DoxyCodeLine{\}}

\end{DoxyCode}
 So if your callback now blocks execution, the user task will also block, and therefore, the whole program is blocked, preventing the system task from running. An approach to move the blocking code out of the callback will lead to this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{sfsc\_adapter adapter;}
\DoxyCodeLine{start\_session\_bootstraped(\&adapter,host,PORT);}
\DoxyCodeLine{while(1)\{ //global execution loop}
\DoxyCodeLine{    system\_task(\&adapter);}
\DoxyCodeLine{    user\_task(\&adapter);}
\DoxyCodeLine{    blocking\_user\_code();}
\DoxyCodeLine{\}}

\end{DoxyCode}
 This is obviously not better than the frist approach, since it will also prevent {\ttfamily system\+\_\+task} from being called. You can try to design your function in the system and user tasks manor and split your long taking operation in multiple substeps and use only non-\/blocking functions yourself. Then, each invocation of your function it will execute only a tiny step of your overall goal. This will result in the following, valid approach\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{sfsc\_adapter adapter;}
\DoxyCodeLine{start\_session\_bootstraped(\&adapter,host,PORT);}
\DoxyCodeLine{int step\_number=0;}
\DoxyCodeLine{while(1)\{ //global execution loop}
\DoxyCodeLine{    system\_task(\&adapter);}
\DoxyCodeLine{    user\_task(\&adapter);}
\DoxyCodeLine{    non\_blocking\_user\_code(step\_number);}
\DoxyCodeLine{    step\_number++;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 So to conclude, if your system task and user task run in the same thread, callbacks and other things you do in your global execution loop should not block. \hypertarget{index_autotoc_md12}{}\doxysubsection{Multi-\/threading}\label{index_autotoc_md12}
If you decide to use multi-\/threading you can set up the system and the user task as different threads. Then, blocking the user task won\textquotesingle{}t interfere with the execution of the system task and is thus allowed. This framework does not include a scheduler, so you have to use your own threading solution. Keep in mind that if you use the a multi-\/threaded execution model, you might have to add some synchronization (see the {\itshape sfsc\+\_\+platform.\+h} section above). \hypertarget{index_autotoc_md13}{}\doxysubsection{Message drop}\label{index_autotoc_md13}
Since the system task writes data to the user ring, and the user tasks takes data from the user ring, it can happen that the user ring gets filled faster than it is emptied (especially if the user task is paused for too long!). In this case, newly received data are dropped (according to the \href{https://rfc.zeromq.org/spec/29/}{\texttt{ ZMTP PUBSUB specification}} on which SFSC is based). \hypertarget{index_autotoc_md14}{}\doxysubsection{Further reading}\label{index_autotoc_md14}
For an in deep discussion and reasoning why this execution model is used, see the white-\/paper, chapter 4.\+9.\hypertarget{index_autotoc_md15}{}\doxysection{Configuration}\label{index_autotoc_md15}
There are several configuration options to adjust the Mirco\+SFSC framework. They can be found in {\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h} and {\ttfamily zmtp\+\_\+config.\+h} and will influence the RAM (and some even ROM) consumption of a {\ttfamily sfsc\+\_\+adapter} struct. The table below list the configuration options, where they can be found, what they are for, and how they change memory consumption. Also, the default values (either a numerical value, or whether the option is defined or not) are listed. Note that all memory sizes are only guide values, the actual values will depend on your platform (e.\+g. on the pointer size or your memory alignment rules). A xN (where N is a number) in the memory column means that the configured value times N bytes of memory is needed.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Parameter Name   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Header   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Memory Impact   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Parameter Name   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Header   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Default   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Memory Impact   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-5}
\endhead
REPLAYS\+\_\+\+PER\+\_\+\+TASK   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &0   &-\/   &The maximum number of micro steps that should be taken per {\ttfamily user\+\_\+task} function invocation, 0 for as many as possible. Example\+: If there are 6 items in the user ring, and REPLAYS\+\_\+\+PER\+\_\+\+TASK is set to 4, only the first 4 of them will be processed in this {\ttfamily user\+\_\+task} call, the next 2 have to wait until the next {\ttfamily user\+\_\+task} call.    \\\cline{1-5}
HEARTBEAT\+\_\+\+SEND\+\_\+\+RATE\+\_\+\+MS   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &400   &-\/   &The time to wait between sending outgoing heartbeats in milliseconds.    \\\cline{1-5}
HEARTBEAT\+\_\+\+DEADLINE\+\_\+\+OUTGOING\+\_\+\+MS   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &HEARTBEAT\+\_\+\+SEND\+\_\+\+RATE\+\_\+\+MS $\ast$ 4   &-\/   &If it was not possible to send at least one heartbeat in this time (denoted in milliseconds) -\/ most likely due to the {\ttfamily system\+\_\+task} function not being called frequent enough -\/ an error will be raised.    \\\cline{1-5}
HEARTBEAT\+\_\+\+DEADLINE\+\_\+\+INCOMING\+\_\+\+MS   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &4000   &-\/   &The amount of time in milliseconds in which a heartbeat from the core needs to arrive. If there is no heartbeat in this amount of time, the SFSC session will be treated as terminated.    \\\cline{1-5}
HAS\+\_\+\+STRING\+\_\+H   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &defined   &a few bytes of ROM if NOT set   &Should be defined if your platform has a {\ttfamily memcpy}, {\ttfamily memset} and {\ttfamily strlen} function. If not defined, inefficient fallback implementations of this functions will be used.    \\\cline{1-5}
MAX\+\_\+\+PUBLISHERS   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &6   &x4 RAM   &Amount of publisher services, a single adapter can operate at the same time. See the {\ttfamily register\+\_\+publisher} function documentation for more information.    \\\cline{1-5}
MAX\+\_\+\+SUBSCRIBERS   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &12   &x4 RAM   &Amount of subscriptions to publisher services, a single adapter can operate at the same time. See the {\ttfamily register\+\_\+subscriber} function documentation for more information.    \\\cline{1-5}
MAX\+\_\+\+PENDING\+\_\+\+ACKS   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &6   &x48 RAM   &Amount of pending acknowledges to transmitted server-\/service-\/answers a single adapter can keep track of at the same time. See the {\ttfamily answer\+\_\+request} function documentation for more information.    \\\cline{1-5}
MAX\+\_\+\+SERVERS   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &6   &x4 RAM   &Amount of server services, a single adapter can operate at the same time. See the {\ttfamily register\+\_\+server} function documentation for more information.    \\\cline{1-5}
MAX\+\_\+\+SIMULTANIOUS\+\_\+\+COMMANDS   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &6   &x24 RAM   &Amount of commands (used for creating or deleting something from a SFSC cores service registry) a single adapter can issue at the same time. Needed in the {\ttfamily register\+\_\+publisher}, {\ttfamily register\+\_\+server} and {\ttfamily unregister\+\_\+publisher}, {\ttfamily unregister\+\_\+server} functions, see there for more information.    \\\cline{1-5}
MAX\+\_\+\+SIMULTANIOUS\+\_\+\+REQUESTS   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &6   &x40 RAM   &Amount pending (not-\/yet answered) requests a single adapter can make at the same time. See the {\ttfamily request} function for more information.    \\\cline{1-5}
REGISTRY\+\_\+\+BUFFER\+\_\+\+SIZE   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &512   &x1 RAM   &When querying the service registry, received services are stored in a buffer of this size. Must not be greater then ZMTP\+\_\+\+IN\+\_\+\+BUFFER\+\_\+\+SIZE (see below; there is no point in storing a service you can not even receive).    \\\cline{1-5}
MAX\+\_\+\+DELETED\+\_\+\+MEMORY   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &32   &x37 RAM   &When querying the service registry, it is necessary to keep track of services in the registry that are marked as deleted (see chapter 4.\+2 in the white-\/paper). This value determines, how many delete events can be stored; if you know that there are many services in your service registry, you may want to increase this value. Note however, that this is not a 1\+:1 relation and you don\textquotesingle{}t need to set this value to the total number of services (if you have 100 services, you don\textquotesingle{}t need to set this value to 100, 32 might be fine). To find the value suited the most for your usecase, you need to experiment a little.    \\\cline{1-5}
USER\+\_\+\+RING\+\_\+\+SIZE   &{\ttfamily sfsc\+\_\+adapter\+\_\+config.\+h}   &5120   &x1 RAM   &The size of the user ring. The default value is chosen this high to prevent message drop, for platforms with lower RAM capabilities, a more appropriate value might be 1024.    \\\cline{1-5}
NO\+\_\+\+CURVE   &{\ttfamily zmtp\+\_\+config.\+h}   &defined   &5 KB(!) RAM and ROM if NOT set   &Curve encryption is wip. It is recommended that you disable the functions related to CRUVE to speed up compilation and reduce the RAM and ROM footprint of the framework.    \\\cline{1-5}
ZMTP\+\_\+\+IN\+\_\+\+BUFFER\+\_\+\+SIZE   &{\ttfamily zmtp\+\_\+config.\+h}   &512   &x4 RAM   &The size of the ZMTP receive buffer; determines, how big a single ZMTP message can be. If you know, that the services you use need to receive bigger payloads (e.\+g. because you want to subscribe a publisher whose messages are 1KB in size), you need to adjust this value.    \\\cline{1-5}
ZMTP\+\_\+\+METADATA\+\_\+\+BUFFER\+\_\+\+SIZE   &{\ttfamily zmtp\+\_\+config.\+h}   &32   &x8 RAM   &ZMTP needs a place to store its meta data. You usually don\textquotesingle{}t need to adjust this buffers size, unless you tweak the ZMTP implementation itself.   \\\cline{1-5}
\end{longtabu}
\hypertarget{index_autotoc_md16}{}\doxysection{Using the API}\label{index_autotoc_md16}
All public API functions are defined in {\ttfamily \mbox{\hyperlink{sfsc__adapter_8h}{sfsc\+\_\+adapter.\+h}}}. You should include this header everywhere you want to use one of the frameworks function. To use most of the functions, you need a pointer to a {\ttfamily sfsc\+\_\+adapter}. To declare a {\ttfamily sfsc\+\_\+adapter}, you also need to include {\ttfamily sfsc\+\_\+adapter\+\_\+struct.\+h}. You should only include this header in the compilation unit you declare the adapter and not modify the struct fields of the adapter. The adapter has a stats field, which tells you some information about its current state. To access the stats field of an adapter, use the {\ttfamily adapter\+\_\+stats} function. After declaring a adapter, you can use it to start a session. Use the {\ttfamily start\+\_\+session\+\_\+bootstraped} or {\ttfamily start\+\_\+session} function with a pointer the the adapter. After the {\ttfamily start\+\_\+session} method returns, your SFSC adapter is ready to perform the SFSC handshake, and you should start using the {\ttfamily system\+\_\+task} function on the adapter. Once the state of the adapter (accessible through the stats field of the adapter struct) is operational, you can also start invoking the {\ttfamily user\+\_\+task} function on the adapter, and use the other API functions with the adapter.

Most functions, including the {\ttfamily system\+\_\+task} and {\ttfamily user\+\_\+task} functions return error codes. An error code of {\ttfamily SFSC\+\_\+\+OK} indicates, that a function call was successful. A full list of error codes can be found in {\ttfamily \mbox{\hyperlink{sfsc__error__codes_8h}{sfsc\+\_\+error\+\_\+codes.\+h}}} and {\ttfamily zmtp\+\_\+stats.\+h}. All errors of {\ttfamily zmtp\+\_\+stats.\+h} indicate that there was something wrong with data transport\+: either the network or the ZMTP protocol (on which SFSC is based) somehow failed. These errors are not recoverable, you should initiate a new SFSC session (you can reuse the adapter struct for that, as long as you set all the fields according to sfsc\+\_\+adapter\+\_\+\+DEFAULT\+\_\+\+INIT, see section {\itshape Struct initalization} below). Errors of {\ttfamily \mbox{\hyperlink{sfsc__error__codes_8h}{sfsc\+\_\+error\+\_\+codes.\+h}}} are higher level and indicate problems with SFSC itself. They are well documented, and some are even recoverable, so look at their documentation.\hypertarget{index_autotoc_md17}{}\doxysubsection{Struct initalization}\label{index_autotoc_md17}
There are some struct types you\textquotesingle{}ll encounter while using the framework. If you want to initialize a struct to its default values (just 0 in almost all cases), you can use the corresponding {\ttfamily $<$struct\+\_\+name$>$\+\_\+\+DEFAULT\+\_\+\+INIT} macro. For some structs there is a constant default instance you can use to copy the default values over, and if there is, its name is {\ttfamily $<$struct\+\_\+name$>$\+\_\+default}. 